"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun thaw (V2821) (V2821))

(defun eval (V2823) (let Macroexpand (shen.walk (lambda Y (macroexpand Y)) V2823) (if (shen.packaged? Macroexpand) (map (lambda Z (shen.eval-without-macros Z)) (shen.package-contents Macroexpand)) (shen.eval-without-macros Macroexpand))))

(defun shen.eval-without-macros (V2825) (eval-kl (shen.elim-def (shen.proc-input+ V2825))))

(defun shen.proc-input+ (V2827) (cond ((and (cons? V2827) (and (= input+ (hd V2827)) (and (cons? (tl V2827)) (and (cons? (tl (tl V2827))) (= () (tl (tl (tl V2827)))))))) (cons input+ (cons (shen.rcons_form (hd (tl V2827))) (tl (tl V2827))))) ((and (cons? V2827) (and (= shen.read+ (hd V2827)) (and (cons? (tl V2827)) (and (cons? (tl (tl V2827))) (= () (tl (tl (tl V2827)))))))) (cons shen.read+ (cons (shen.rcons_form (hd (tl V2827))) (tl (tl V2827))))) ((cons? V2827) (map (lambda Z (shen.proc-input+ Z)) V2827)) (true V2827)))

(defun shen.elim-def (V2829) (cond ((and (cons? V2829) (and (= define (hd V2829)) (cons? (tl V2829)))) (shen.shen->kl (hd (tl V2829)) (tl (tl V2829)))) ((and (cons? V2829) (and (= defmacro (hd V2829)) (cons? (tl V2829)))) (let Default (cons X (cons -> (cons X ()))) (let Def (shen.elim-def (cons define (cons (hd (tl V2829)) (append (tl (tl V2829)) Default)))) (let MacroAdd (shen.add-macro (hd (tl V2829))) Def)))) ((and (cons? V2829) (and (= defcc (hd V2829)) (cons? (tl V2829)))) (shen.elim-def (shen.yacc V2829))) ((cons? V2829) (map (lambda Z (shen.elim-def Z)) V2829)) (true V2829)))

(defun shen.add-macro (V2831) (let MacroReg (value shen.*macroreg*) (let NewMacroReg (set shen.*macroreg* (adjoin V2831 (value shen.*macroreg*))) (if (= MacroReg NewMacroReg) shen.skip (set *macros* (cons (function V2831) (value *macros*)))))))

(defun shen.packaged? (V2839) (cond ((and (cons? V2839) (and (= package (hd V2839)) (and (cons? (tl V2839)) (cons? (tl (tl V2839)))))) true) (true false)))

(defun external (V2841) (get/or V2841 shen.external-symbols (freeze (simple-error (cn "package " (shen.app V2841 " has not been used.
" shen.a)))) (value *property-vector*)))

(defun internal (V2843) (get/or V2843 shen.internal-symbols (freeze (simple-error (cn "package " (shen.app V2843 " has not been used.
" shen.a)))) (value *property-vector*)))

(defun shen.package-contents (V2847) (cond ((and (cons? V2847) (and (= package (hd V2847)) (and (cons? (tl V2847)) (and (= null (hd (tl V2847))) (cons? (tl (tl V2847))))))) (tl (tl (tl V2847)))) ((and (cons? V2847) (and (= package (hd V2847)) (and (cons? (tl V2847)) (cons? (tl (tl V2847)))))) (shen.packageh (hd (tl V2847)) (hd (tl (tl V2847))) (tl (tl (tl V2847))))) (true (shen.f_error shen.package-contents))))

(defun shen.walk (V2850 V2851) (cond ((cons? V2851) (V2850 (map (lambda Z (shen.walk V2850 Z)) V2851))) (true (V2850 V2851))))

(defun compile (V2855 V2856 V2857) (let O (V2855 (cons V2856 (cons () ()))) (if (or (= (fail) O) (not (empty? (hd O)))) (V2857 O) (shen.hdtl O))))

(defun fail-if (V2860 V2861) (if (V2860 V2861) (fail) V2861))

(defun @s (V2864 V2865) (cn V2864 V2865))

(defun tc? () (value shen.*tc*))

(defun ps (V2867) (get/or V2867 shen.source (freeze (simple-error (shen.app V2867 " not found.
" shen.a))) (value *property-vector*)))

(defun stinput () (value *stinput*))

(defun <-address/or (V2871 V2872 V2873) (trap-error (<-address V2871 V2872) (lambda E (thaw V2873))))

(defun value/or (V2876 V2877) (trap-error (value V2876) (lambda E (thaw V2877))))

(defun vector (V2879) (let Vector (absvector (+ V2879 1)) (let ZeroStamp (address-> Vector 0 V2879) (let Standard (if (= V2879 0) ZeroStamp (shen.fillvector ZeroStamp 1 V2879 (fail))) Standard))))

(defun shen.fillvector (V2885 V2886 V2887 V2888) (cond ((= V2887 V2886) (address-> V2885 V2887 V2888)) (true (shen.fillvector (address-> V2885 V2886 V2888) (+ 1 V2886) V2887 V2888))))

(defun vector? (V2890) (and (absvector? V2890) (let X (<-address/or V2890 0 (freeze -1)) (and (number? X) (>= X 0)))))

(defun vector-> (V2894 V2895 V2896) (if (= V2895 0) (simple-error "cannot access 0th element of a vector
") (address-> V2894 V2895 V2896)))

(defun <-vector (V2899 V2900) (if (= V2900 0) (simple-error "cannot access 0th element of a vector
") (let VectorElement (<-address V2899 V2900) (if (= VectorElement (fail)) (simple-error "vector element not found
") VectorElement))))

(defun <-vector/or (V2904 V2905 V2906) (if (= V2905 0) (simple-error "cannot access 0th element of a vector
") (let VectorElement (<-address/or V2904 V2905 V2906) (if (= VectorElement (fail)) (thaw V2906) VectorElement))))

(defun shen.posint? (V2908) (and (integer? V2908) (>= V2908 0)))

(defun limit (V2910) (<-address V2910 0))

(defun symbol? (V2912) (cond ((or (boolean? V2912) (or (number? V2912) (string? V2912))) false) (true (trap-error (let String (str V2912) (shen.analyse-symbol? String)) (lambda E false)))))

(defun shen.analyse-symbol? (V2914) (cond ((= "" V2914) false) ((shen.+string? V2914) (and (shen.alpha? (pos V2914 0)) (shen.alphanums? (tlstr V2914)))) (true (shen.f_error shen.analyse-symbol?))))

(defun shen.alpha? (V2916) (element? V2916 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" (cons "a" (cons "b" (cons "c" (cons "d" (cons "e" (cons "f" (cons "g" (cons "h" (cons "i" (cons "j" (cons "k" (cons "l" (cons "m" (cons "n" (cons "o" (cons "p" (cons "q" (cons "r" (cons "s" (cons "t" (cons "u" (cons "v" (cons "w" (cons "x" (cons "y" (cons "z" (cons "=" (cons "*" (cons "/" (cons "+" (cons "-" (cons "_" (cons "?" (cons "$" (cons "!" (cons "@" (cons "~" (cons ">" (cons "<" (cons "&" (cons "%" (cons "{" (cons "}" (cons ":" (cons ";" (cons "`" (cons "#" (cons "'" (cons "." ())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

(defun shen.alphanums? (V2918) (cond ((= "" V2918) true) ((shen.+string? V2918) (and (shen.alphanum? (pos V2918 0)) (shen.alphanums? (tlstr V2918)))) (true (shen.f_error shen.alphanums?))))

(defun shen.alphanum? (V2920) (or (shen.alpha? V2920) (shen.digit? V2920)))

(defun shen.digit? (V2922) (element? V2922 (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" ()))))))))))))

(defun variable? (V2924) (cond ((or (boolean? V2924) (or (number? V2924) (string? V2924))) false) (true (trap-error (let String (str V2924) (shen.analyse-variable? String)) (lambda E false)))))

(defun shen.analyse-variable? (V2926) (cond ((shen.+string? V2926) (and (shen.uppercase? (pos V2926 0)) (shen.alphanums? (tlstr V2926)))) (true (shen.f_error shen.analyse-variable?))))

(defun shen.uppercase? (V2928) (element? V2928 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" ()))))))))))))))))))))))))))))

(defun gensym (V2930) (concat V2930 (set shen.*gensym* (+ 1 (value shen.*gensym*)))))

(defun concat (V2933 V2934) (intern (cn (str V2933) (str V2934))))

(defun @p (V2937 V2938) (let Vector (absvector 3) (let Tag (address-> Vector 0 shen.tuple) (let Fst (address-> Vector 1 V2937) (let Snd (address-> Vector 2 V2938) Vector)))))

(defun fst (V2940) (<-address V2940 1))

(defun snd (V2942) (<-address V2942 2))

(defun tuple? (V2944) (and (absvector? V2944) (= shen.tuple (<-address/or V2944 0 (freeze shen.not-tuple)))))

(defun append (V2947 V2948) (cond ((= () V2947) V2948) ((cons? V2947) (cons (hd V2947) (append (tl V2947) V2948))) (true (shen.f_error append))))

(defun @v (V2951 V2952) (let Limit (limit V2952) (let NewVector (vector (+ Limit 1)) (let X+NewVector (vector-> NewVector 1 V2951) (if (= Limit 0) X+NewVector (shen.@v-help V2952 1 Limit X+NewVector))))))

(defun shen.@v-help (V2958 V2959 V2960 V2961) (cond ((= V2960 V2959) (shen.copyfromvector V2958 V2961 V2960 (+ V2960 1))) (true (shen.@v-help V2958 (+ V2959 1) V2960 (shen.copyfromvector V2958 V2961 V2959 (+ V2959 1))))))

(defun shen.copyfromvector (V2966 V2967 V2968 V2969) (trap-error (vector-> V2967 V2969 (<-vector V2966 V2968)) (lambda E V2967)))

(defun hdv (V2971) (<-vector/or V2971 1 (freeze (simple-error (cn "hdv needs a non-empty vector as an argument; not " (shen.app V2971 "
" shen.s))))))

(defun tlv (V2973) (let Limit (limit V2973) (if (= Limit 0) (simple-error "cannot take the tail of the empty vector
") (if (= Limit 1) (vector 0) (let NewVector (vector (- Limit 1)) (shen.tlv-help V2973 2 Limit (vector (- Limit 1))))))))

(defun shen.tlv-help (V2979 V2980 V2981 V2982) (cond ((= V2981 V2980) (shen.copyfromvector V2979 V2982 V2981 (- V2981 1))) (true (shen.tlv-help V2979 (+ V2980 1) V2981 (shen.copyfromvector V2979 V2982 V2980 (- V2980 1))))))

(defun assoc (V2994 V2995) (cond ((= () V2995) ()) ((and (cons? V2995) (and (cons? (hd V2995)) (= (hd (hd V2995)) V2994))) (hd V2995)) ((cons? V2995) (assoc V2994 (tl V2995))) (true (shen.f_error assoc))))

(defun boolean? (V3001) (cond ((= true V3001) true) ((= false V3001) true) (true false)))

(defun nl (V3003) (cond ((= 0 V3003) 0) (true (do (shen.prhush "
" (stoutput)) (nl (- V3003 1))))))

(defun difference (V3008 V3009) (cond ((= () V3008) ()) ((cons? V3008) (if (element? (hd V3008) V3009) (difference (tl V3008) V3009) (cons (hd V3008) (difference (tl V3008) V3009)))) (true (shen.f_error difference))))

(defun do (V3012 V3013) V3013)

(defun element? (V3025 V3026) (cond ((= () V3026) false) ((and (cons? V3026) (= (hd V3026) V3025)) true) ((cons? V3026) (element? V3025 (tl V3026))) (true (shen.f_error element?))))

(defun empty? (V3032) (cond ((= () V3032) true) (true false)))

(defun fix (V3035 V3036) (shen.fix-help V3035 V3036 (V3035 V3036)))

(defun shen.fix-help (V3047 V3048 V3049) (cond ((= V3049 V3048) V3049) (true (shen.fix-help V3047 V3049 (V3047 V3049)))))

(defun dict (V3051) (let D (absvector (+ 3 V3051)) (let Tag (address-> D 0 shen.dictionary) (let Capacity (address-> D 1 V3051) (let Count (address-> D 2 0) (let Fill (shen.fillvector D 3 (+ 2 V3051) ()) D))))))

(defun dict? (V3053) (and (absvector? V3053) (= (<-address/or V3053 0 (freeze shen.not-dictionary)) shen.dictionary)))

(defun shen.dict-capacity (V3055) (<-address V3055 1))

(defun dict-count (V3057) (<-address V3057 2))

(defun shen.dict-count-> (V3060 V3061) (address-> V3060 2 V3061))

(defun shen.<-dict-bucket (V3064 V3065) (<-address V3064 (+ 3 V3065)))

(defun shen.dict-bucket-> (V3069 V3070 V3071) (address-> V3069 (+ 3 V3070) V3071))

(defun shen.set-key-entry-value (V3078 V3079 V3080) (cond ((= () V3080) (cons (cons V3078 V3079) ())) ((and (cons? V3080) (and (cons? (hd V3080)) (= (hd (hd V3080)) V3078))) (cons (cons (hd (hd V3080)) V3079) (tl V3080))) ((cons? V3080) (cons (hd V3080) (shen.set-key-entry-value V3078 V3079 (tl V3080)))) (true (shen.f_error shen.set-key-entry-value))))

(defun shen.remove-key-entry-value (V3086 V3087) (cond ((= () V3087) ()) ((and (cons? V3087) (and (cons? (hd V3087)) (= (hd (hd V3087)) V3086))) (tl V3087)) ((cons? V3087) (cons (hd V3087) (shen.remove-key-entry-value V3086 (tl V3087)))) (true (shen.f_error shen.remove-key-entry-value))))

(defun shen.dict-update-count (V3091 V3092 V3093) (let Diff (- (length V3093) (length V3092)) (shen.dict-count-> V3091 (+ Diff (dict-count V3091)))))

(defun dict-> (V3097 V3098 V3099) (let N (hash V3098 (shen.dict-capacity V3097)) (let Bucket (shen.<-dict-bucket V3097 N) (let NewBucket (shen.set-key-entry-value V3098 V3099 Bucket) (let Change (shen.dict-bucket-> V3097 N NewBucket) (let Count (shen.dict-update-count V3097 Bucket NewBucket) V3099))))))

(defun <-dict/or (V3103 V3104 V3105) (let N (hash V3104 (shen.dict-capacity V3103)) (let Bucket (shen.<-dict-bucket V3103 N) (let Result (assoc V3104 Bucket) (if (empty? Result) (thaw V3105) (tl Result))))))

(defun <-dict (V3108 V3109) (<-dict/or V3108 V3109 (freeze (simple-error "value not found
"))))

(defun dict-rm (V3112 V3113) (let N (hash V3113 (shen.dict-capacity V3112)) (let Bucket (shen.<-dict-bucket V3112 N) (let NewBucket (shen.remove-key-entry-value V3113 Bucket) (let Change (shen.dict-bucket-> V3112 N NewBucket) (let Count (shen.dict-update-count V3112 Bucket NewBucket) V3113))))))

(defun dict-fold (V3117 V3118 V3119) (let Limit (shen.dict-capacity V3118) (shen.dict-fold-h V3117 V3118 V3119 0 Limit)))

(defun shen.dict-fold-h (V3126 V3127 V3128 V3129 V3130) (cond ((= V3130 V3129) V3128) (true (let B (shen.<-dict-bucket V3127 V3129) (let Acc (shen.bucket-fold V3126 B V3128) (shen.dict-fold-h V3126 V3127 Acc (+ 1 V3129) V3130))))))

(defun shen.bucket-fold (V3134 V3135 V3136) (cond ((= () V3135) V3136) ((and (cons? V3135) (cons? (hd V3135))) (V3134 (hd (hd V3135)) (tl (hd V3135)) (shen.bucket-fold V3134 (tl V3135) V3136))) (true (shen.f_error shen.bucket-fold))))

(defun dict-keys (V3138) (dict-fold (lambda K (lambda _ (lambda Acc (cons K Acc)))) V3138 ()))

(defun dict-values (V3140) (dict-fold (lambda _ (lambda V (lambda Acc (cons V Acc)))) V3140 ()))

(defun put (V3145 V3146 V3147 V3148) (let Curr (<-dict/or V3148 V3145 (freeze ())) (let Added (shen.set-key-entry-value V3146 V3147 Curr) (let Update (dict-> V3148 V3145 Added) V3147))))

(defun unput (V3152 V3153 V3154) (let Curr (<-dict/or V3154 V3152 (freeze ())) (let Removed (shen.remove-key-entry-value V3153 Curr) (let Update (dict-> V3154 V3152 Removed) V3152))))

(defun get/or (V3159 V3160 V3161 V3162) (let Entry (<-dict/or V3162 V3159 (freeze ())) (let Result (assoc V3160 Entry) (if (empty? Result) (thaw V3161) (tl Result)))))

(defun get (V3166 V3167 V3168) (get/or V3166 V3167 (freeze (simple-error "value not found
")) V3168))

(defun hash (V3171 V3172) (shen.mod (sum (map (lambda X (string->n X)) (explode V3171))) V3172))

(defun shen.mod (V3175 V3176) (shen.modh V3175 (shen.multiples V3175 (cons V3176 ()))))

(defun shen.multiples (V3179 V3180) (cond ((and (cons? V3180) (> (hd V3180) V3179)) (tl V3180)) ((cons? V3180) (shen.multiples V3179 (cons (* 2 (hd V3180)) V3180))) (true (shen.f_error shen.multiples))))

(defun shen.modh (V3185 V3186) (cond ((= 0 V3185) 0) ((= () V3186) V3185) ((and (cons? V3186) (> (hd V3186) V3185)) (if (empty? (tl V3186)) V3185 (shen.modh V3185 (tl V3186)))) ((cons? V3186) (shen.modh (- V3185 (hd V3186)) V3186)) (true (shen.f_error shen.modh))))

(defun sum (V3188) (cond ((= () V3188) 0) ((cons? V3188) (+ (hd V3188) (sum (tl V3188)))) (true (shen.f_error sum))))

(defun head (V3196) (cond ((cons? V3196) (hd V3196)) (true (simple-error "head expects a non-empty list"))))

(defun tail (V3204) (cond ((cons? V3204) (tl V3204)) (true (simple-error "tail expects a non-empty list"))))

(defun hdstr (V3206) (pos V3206 0))

(defun intersection (V3211 V3212) (cond ((= () V3211) ()) ((cons? V3211) (if (element? (hd V3211) V3212) (cons (hd V3211) (intersection (tl V3211) V3212)) (intersection (tl V3211) V3212))) (true (shen.f_error intersection))))

(defun reverse (V3214) (shen.reverse_help V3214 ()))

(defun shen.reverse_help (V3217 V3218) (cond ((= () V3217) V3218) ((cons? V3217) (shen.reverse_help (tl V3217) (cons (hd V3217) V3218))) (true (shen.f_error shen.reverse_help))))

(defun union (V3221 V3222) (cond ((= () V3221) V3222) ((cons? V3221) (if (element? (hd V3221) V3222) (union (tl V3221) V3222) (cons (hd V3221) (union (tl V3221) V3222)))) (true (shen.f_error union))))

(defun y-or-n? (V3224) (let Message (shen.prhush (shen.proc-nl V3224) (stoutput)) (let Y-or-N (shen.prhush " (y/n) " (stoutput)) (let Input (shen.app (read (stinput)) "" shen.s) (if (= "y" Input) true (if (= "n" Input) false (do (shen.prhush "please answer y or n
" (stoutput)) (y-or-n? V3224))))))))

(defun not (V3226) (if V3226 false true))

(defun subst (V3239 V3240 V3241) (cond ((= V3241 V3240) V3239) ((cons? V3241) (map (lambda W (subst V3239 V3240 W)) V3241)) (true V3241)))

(defun explode (V3243) (shen.explode-h (shen.app V3243 "" shen.a)))

(defun shen.explode-h (V3245) (cond ((= "" V3245) ()) ((shen.+string? V3245) (cons (pos V3245 0) (shen.explode-h (tlstr V3245)))) (true (shen.f_error shen.explode-h))))

(defun cd (V3247) (set *home-directory* (if (= V3247 "") "" (shen.app V3247 "/" shen.a))))

(defun for-each (V3250 V3251) (cond ((= () V3251) true) ((cons? V3251) (let _ (V3250 (hd V3251)) (for-each V3250 (tl V3251)))) (true (shen.f_error for-each))))

(defun fold-right (V3255 V3256 V3257) (cond ((= () V3256) V3257) ((cons? V3256) (V3255 (hd V3256) (fold-right V3255 (tl V3256) V3257))) (true (shen.f_error fold-right))))

(defun fold-left (V3261 V3262 V3263) (cond ((= () V3263) V3262) ((cons? V3263) (fold-left V3261 (V3261 V3262 (hd V3263)) (tl V3263))) (true (shen.f_error fold-left))))

(defun filter (V3266 V3267) (shen.filter-h V3266 () V3267))

(defun shen.filter-h (V3277 V3278 V3279) (cond ((= () V3279) (reverse V3278)) ((and (cons? V3279) (V3277 (hd V3279))) (shen.filter-h V3277 (cons (hd V3279) V3278) (tl V3279))) ((cons? V3279) (shen.filter-h V3277 V3278 (tl V3279))) (true (shen.f_error shen.filter-h))))

(defun map (V3282 V3283) (shen.map-h V3282 V3283 ()))

(defun shen.map-h (V3289 V3290 V3291) (cond ((= () V3290) (reverse V3291)) ((cons? V3290) (shen.map-h V3289 (tl V3290) (cons (V3289 (hd V3290)) V3291))) (true (shen.f_error shen.map-h))))

(defun length (V3293) (shen.length-h V3293 0))

(defun shen.length-h (V3296 V3297) (cond ((= () V3296) V3297) (true (shen.length-h (tl V3296) (+ V3297 1)))))

(defun occurrences (V3309 V3310) (cond ((= V3310 V3309) 1) ((cons? V3310) (+ (occurrences V3309 (hd V3310)) (occurrences V3309 (tl V3310)))) (true 0)))

(defun nth (V3319 V3320) (cond ((and (= 1 V3319) (cons? V3320)) (hd V3320)) ((cons? V3320) (nth (- V3319 1) (tl V3320))) (true (shen.f_error nth))))

(defun integer? (V3322) (and (number? V3322) (let Abs (shen.abs V3322) (shen.integer-test? Abs (shen.magless Abs 1)))))

(defun shen.abs (V3324) (if (> V3324 0) V3324 (- 0 V3324)))

(defun shen.magless (V3327 V3328) (let Nx2 (* V3328 2) (if (> Nx2 V3327) V3328 (shen.magless V3327 Nx2))))

(defun shen.integer-test? (V3334 V3335) (cond ((= 0 V3334) true) ((> 1 V3334) false) (true (let Abs-N (- V3334 V3335) (if (> 0 Abs-N) (integer? V3334) (shen.integer-test? Abs-N V3335))))))

(defun mapcan (V3340 V3341) (cond ((= () V3341) ()) ((cons? V3341) (append (V3340 (hd V3341)) (mapcan V3340 (tl V3341)))) (true (shen.f_error mapcan))))

(defun == (V3353 V3354) (cond ((= V3354 V3353) true) (true false)))

(defun abort () (simple-error ""))

(defun bound? (V3356) (and (symbol? V3356) (let Val (value/or V3356 (freeze shen.this-symbol-is-unbound)) (if (= Val shen.this-symbol-is-unbound) false true))))

(defun shen.string->bytes (V3358) (cond ((= "" V3358) ()) (true (cons (string->n (pos V3358 0)) (shen.string->bytes (tlstr V3358))))))

(defun maxinferences (V3360) (set shen.*maxinferences* V3360))

(defun inferences () (value shen.*infs*))

(defun protect (V3362) V3362)

(defun stoutput () (value *stoutput*))

(defun sterror () (value *sterror*))

(defun command-line () (value *argv*))

(defun string->symbol (V3364) (let Symbol (intern V3364) (if (symbol? Symbol) Symbol (simple-error (cn "cannot intern " (shen.app V3364 " to a symbol" shen.s))))))

(defun optimise (V3370) (cond ((= + V3370) (set shen.*optimise* true)) ((= - V3370) (set shen.*optimise* false)) (true (simple-error "optimise expects a + or a -.
"))))

(defun os () (value *os*))

(defun language () (value *language*))

(defun version () (value *version*))

(defun port () (value *port*))

(defun porters () (value *porters*))

(defun implementation () (value *implementation*))

(defun release () (value *release*))

(defun package? (V3372) (trap-error (do (external V3372) true) (lambda E false)))

(defun function (V3374) (shen.lookup-func V3374))

(defun shen.lookup-func (V3376) (get/or V3376 shen.lambda-form (freeze (simple-error (shen.app V3376 " has no lambda expansion
" shen.a))) (value *property-vector*)))



