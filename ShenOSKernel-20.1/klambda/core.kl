"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.shen->kl (V1378 V1379) (compile (lambda X (shen.<define> X)) (cons V1378 V1379) (lambda X (shen.shen-syntax-error V1378 X))))

(defun shen.shen-syntax-error (V1386 V1387) (cond ((cons? V1387) (simple-error (cn "syntax error in " (shen.app V1386 (cn " here:

 " (shen.app (shen.next-50 50 (hd V1387)) "
" shen.a)) shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V1386 "
" shen.a))))))

(defun shen.<define> (V1389) (let YaccParse (let Parse_shen.<name> (shen.<name> V1389) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<signature> (shen.<signature> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<name> (shen.<name> V1389) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) YaccParse)))

(defun shen.<name> (V1391) (if (cons? (hd V1391)) (let Parse_X (hd (hd V1391)) (shen.pair (hd (shen.pair (tl (hd V1391)) (shen.hdtl V1391))) (if (and (symbol? Parse_X) (not (shen.sysfunc? Parse_X))) Parse_X (simple-error (shen.app Parse_X " is not a legitimate function name.
" shen.a))))) (fail)))

(defun shen.sysfunc? (V1393) (element? V1393 (get (intern "shen") shen.external-symbols (value *property-vector*))))

(defun shen.<signature> (V1395) (if (and (cons? (hd V1395)) (= { (hd (hd V1395)))) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V1395)) (shen.hdtl V1395))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (and (cons? (hd Parse_shen.<signature-help>)) (= } (hd (hd Parse_shen.<signature-help>)))) (shen.pair (hd (shen.pair (tl (hd Parse_shen.<signature-help>)) (shen.hdtl Parse_shen.<signature-help>))) (shen.demodulate (shen.curry-type (shen.hdtl Parse_shen.<signature-help>)))) (fail)) (fail))) (fail)))

(defun shen.curry-type (V1397) (cond ((and (cons? V1397) (and (cons? (tl V1397)) (and (= --> (hd (tl V1397))) (and (cons? (tl (tl V1397))) (and (cons? (tl (tl (tl V1397)))) (= --> (hd (tl (tl (tl V1397)))))))))) (shen.curry-type (cons (hd V1397) (cons --> (cons (tl (tl V1397)) ()))))) ((and (cons? V1397) (and (cons? (tl V1397)) (and (= * (hd (tl V1397))) (and (cons? (tl (tl V1397))) (and (cons? (tl (tl (tl V1397)))) (= * (hd (tl (tl (tl V1397)))))))))) (shen.curry-type (cons (hd V1397) (cons * (cons (tl (tl V1397)) ()))))) ((cons? V1397) (map (lambda Z (shen.curry-type Z)) V1397)) (true V1397)))

(defun shen.<signature-help> (V1399) (let YaccParse (if (cons? (hd V1399)) (let Parse_X (hd (hd V1399)) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V1399)) (shen.hdtl V1399))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (not (element? Parse_X (cons { (cons } ())))) (shen.pair (hd Parse_shen.<signature-help>) (cons Parse_X (shen.hdtl Parse_shen.<signature-help>))) (fail)) (fail)))) (fail)) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1399) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<rules> (V1401) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V1401) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V1401) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) ())) (fail))) YaccParse)))

(defun shen.<rule> (V1403) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1403) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<action>) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1403) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<action>) ()))) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1403) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<patterns> (shen.<patterns> V1403) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) (fail))) (fail)) (fail))) YaccParse)) YaccParse)) YaccParse)))

(defun shen.fail_if (V1406 V1407) (if (V1406 V1407) (fail) V1407))

(defun shen.succeeds? (V1413) (cond ((= V1413 (fail)) false) (true true)))

(defun shen.<patterns> (V1415) (let YaccParse (let Parse_shen.<pattern> (shen.<pattern> V1415) (if (not (= (fail) Parse_shen.<pattern>)) (let Parse_shen.<patterns> (shen.<patterns> Parse_shen.<pattern>) (if (not (= (fail) Parse_shen.<patterns>)) (shen.pair (hd Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<pattern>) (shen.hdtl Parse_shen.<patterns>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1415) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<pattern> (V1422) (let YaccParse (if (and (cons? (hd V1422)) (cons? (hd (hd V1422)))) (if (and (cons? (hd (shen.pair (hd (hd V1422)) (hd (tl V1422))))) (= @p (hd (hd (shen.pair (hd (hd V1422)) (hd (tl V1422))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1422)) (hd (tl V1422))))) (shen.hdtl (shen.pair (hd (hd V1422)) (hd (tl V1422)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1422)) (hd (tl V1422)))) (cons @p (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1422)) (cons? (hd (hd V1422)))) (if (and (cons? (hd (shen.pair (hd (hd V1422)) (hd (tl V1422))))) (= cons (hd (hd (shen.pair (hd (hd V1422)) (hd (tl V1422))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1422)) (hd (tl V1422))))) (shen.hdtl (shen.pair (hd (hd V1422)) (hd (tl V1422)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1422)) (hd (tl V1422)))) (cons cons (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1422)) (cons? (hd (hd V1422)))) (if (and (cons? (hd (shen.pair (hd (hd V1422)) (hd (tl V1422))))) (= @v (hd (hd (shen.pair (hd (hd V1422)) (hd (tl V1422))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1422)) (hd (tl V1422))))) (shen.hdtl (shen.pair (hd (hd V1422)) (hd (tl V1422)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1422)) (hd (tl V1422)))) (cons @v (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1422)) (cons? (hd (hd V1422)))) (if (and (cons? (hd (shen.pair (hd (hd V1422)) (hd (tl V1422))))) (= @s (hd (hd (shen.pair (hd (hd V1422)) (hd (tl V1422))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1422)) (hd (tl V1422))))) (shen.hdtl (shen.pair (hd (hd V1422)) (hd (tl V1422)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1422)) (hd (tl V1422)))) (cons @s (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1422)) (cons? (hd (hd V1422)))) (if (and (cons? (hd (shen.pair (hd (hd V1422)) (hd (tl V1422))))) (= vector (hd (hd (shen.pair (hd (hd V1422)) (hd (tl V1422))))))) (if (and (cons? (hd (shen.pair (tl (hd (shen.pair (hd (hd V1422)) (hd (tl V1422))))) (shen.hdtl (shen.pair (hd (hd V1422)) (hd (tl V1422))))))) (= 0 (hd (hd (shen.pair (tl (hd (shen.pair (hd (hd V1422)) (hd (tl V1422))))) (shen.hdtl (shen.pair (hd (hd V1422)) (hd (tl V1422))))))))) (shen.pair (hd (shen.pair (tl (hd V1422)) (hd (tl V1422)))) (cons vector (cons 0 ()))) (fail)) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (cons? (hd V1422)) (let Parse_X (hd (hd V1422)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V1422)) (shen.hdtl V1422))) (shen.constructor-error Parse_X)) (fail))) (fail)) (if (= YaccParse (fail)) (let Parse_shen.<simple_pattern> (shen.<simple_pattern> V1422) (if (not (= (fail) Parse_shen.<simple_pattern>)) (shen.pair (hd Parse_shen.<simple_pattern>) (shen.hdtl Parse_shen.<simple_pattern>)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.constructor-error (V1424) (simple-error (shen.app V1424 " is not a legitimate constructor
" shen.a)))

(defun shen.<simple_pattern> (V1426) (let YaccParse (if (cons? (hd V1426)) (let Parse_X (hd (hd V1426)) (if (= Parse_X _) (shen.pair (hd (shen.pair (tl (hd V1426)) (shen.hdtl V1426))) (gensym Parse_Y)) (fail))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V1426)) (let Parse_X (hd (hd V1426)) (if (not (element? Parse_X (cons -> (cons <- ())))) (shen.pair (hd (shen.pair (tl (hd V1426)) (shen.hdtl V1426))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<pattern1> (V1428) (let Parse_shen.<pattern> (shen.<pattern> V1428) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<pattern2> (V1430) (let Parse_shen.<pattern> (shen.<pattern> V1430) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<action> (V1432) (if (cons? (hd V1432)) (let Parse_X (hd (hd V1432)) (shen.pair (hd (shen.pair (tl (hd V1432)) (shen.hdtl V1432))) Parse_X)) (fail)))

(defun shen.<guard> (V1434) (if (cons? (hd V1434)) (let Parse_X (hd (hd V1434)) (shen.pair (hd (shen.pair (tl (hd V1434)) (shen.hdtl V1434))) Parse_X)) (fail)))

(defun shen.compile_to_machine_code (V1437 V1438) (let Lambda+ (shen.compile_to_lambda+ V1437 V1438) (let KL (shen.compile_to_kl V1437 Lambda+) (let Record (shen.record-source V1437 KL) KL))))

(defun shen.record-source (V1443 V1444) (cond ((value shen.*installing-kl*) shen.skip) (true (put V1443 shen.source V1444 (value *property-vector*)))))

(defun shen.compile_to_lambda+ (V1447 V1448) (let Arity (shen.aritycheck V1447 V1448) (let UpDateSymbolTable (shen.update-symbol-table V1447 Arity) (let Free (for-each (lambda Rule (shen.free_variable_check V1447 Rule)) V1448) (let Variables (shen.parameters Arity) (let Strip (map (lambda X (shen.strip-protect X)) V1448) (let Abstractions (map (lambda X (shen.abstract_rule X)) Strip) (let Applications (map (lambda X (shen.application_build Variables X)) Abstractions) (cons Variables (cons Applications ()))))))))))

(defun shen.update-symbol-table (V1451 V1452) (cond ((= 0 V1452) shen.skip) (true (put V1451 shen.lambda-form (eval-kl (shen.lambda-form V1451 V1452)) (value *property-vector*)))))

(defun shen.free_variable_check (V1455 V1456) (cond ((and (cons? V1456) (and (cons? (tl V1456)) (= () (tl (tl V1456))))) (let Bound (shen.extract_vars (hd V1456)) (let Free (shen.extract_free_vars Bound (hd (tl V1456))) (shen.free_variable_warnings V1455 Free)))) (true (shen.f_error shen.free_variable_check))))

(defun shen.extract_vars (V1458) (cond ((variable? V1458) (cons V1458 ())) ((cons? V1458) (union (shen.extract_vars (hd V1458)) (shen.extract_vars (tl V1458)))) (true ())))

(defun shen.extract_free_vars (V1470 V1471) (cond ((and (cons? V1471) (and (cons? (tl V1471)) (and (= () (tl (tl V1471))) (= (hd V1471) protect)))) ()) ((and (variable? V1471) (not (element? V1471 V1470))) (cons V1471 ())) ((and (cons? V1471) (and (= lambda (hd V1471)) (and (cons? (tl V1471)) (and (cons? (tl (tl V1471))) (= () (tl (tl (tl V1471)))))))) (shen.extract_free_vars (cons (hd (tl V1471)) V1470) (hd (tl (tl V1471))))) ((and (cons? V1471) (and (= let (hd V1471)) (and (cons? (tl V1471)) (and (cons? (tl (tl V1471))) (and (cons? (tl (tl (tl V1471)))) (= () (tl (tl (tl (tl V1471)))))))))) (union (shen.extract_free_vars V1470 (hd (tl (tl V1471)))) (shen.extract_free_vars (cons (hd (tl V1471)) V1470) (hd (tl (tl (tl V1471))))))) ((cons? V1471) (union (shen.extract_free_vars V1470 (hd V1471)) (shen.extract_free_vars V1470 (tl V1471)))) (true ())))

(defun shen.free_variable_warnings (V1476 V1477) (cond ((= () V1477) _) (true (simple-error (cn "error: the following variables are free in " (shen.app V1476 (cn ": " (shen.app (shen.list_variables V1477) "" shen.a)) shen.a))))))

(defun shen.list_variables (V1479) (cond ((and (cons? V1479) (= () (tl V1479))) (cn (str (hd V1479)) ".")) ((cons? V1479) (cn (str (hd V1479)) (cn ", " (shen.list_variables (tl V1479))))) (true (shen.f_error shen.list_variables))))

(defun shen.strip-protect (V1481) (cond ((and (cons? V1481) (and (cons? (tl V1481)) (and (= () (tl (tl V1481))) (= (hd V1481) protect)))) (shen.strip-protect (hd (tl V1481)))) ((cons? V1481) (map (lambda Z (shen.strip-protect Z)) V1481)) (true V1481)))

(defun shen.linearise (V1483) (cond ((and (cons? V1483) (and (cons? (tl V1483)) (= () (tl (tl V1483))))) (shen.linearise_help (shen.flatten (hd V1483)) (hd V1483) (hd (tl V1483)))) (true (shen.f_error shen.linearise))))

(defun shen.flatten (V1485) (cond ((= () V1485) ()) ((cons? V1485) (append (shen.flatten (hd V1485)) (shen.flatten (tl V1485)))) (true (cons V1485 ()))))

(defun shen.linearise_help (V1489 V1490 V1491) (cond ((= () V1489) (cons V1490 (cons V1491 ()))) ((cons? V1489) (if (and (variable? (hd V1489)) (element? (hd V1489) (tl V1489))) (let Var (gensym (hd V1489)) (let NewAction (cons where (cons (cons = (cons (hd V1489) (cons Var ()))) (cons V1491 ()))) (let NewPatts (shen.linearise_X (hd V1489) Var V1490) (shen.linearise_help (tl V1489) NewPatts NewAction)))) (shen.linearise_help (tl V1489) V1490 V1491))) (true (shen.f_error shen.linearise_help))))

(defun shen.linearise_X (V1504 V1505 V1506) (cond ((= V1506 V1504) V1505) ((cons? V1506) (let L (shen.linearise_X V1504 V1505 (hd V1506)) (if (= L (hd V1506)) (cons (hd V1506) (shen.linearise_X V1504 V1505 (tl V1506))) (cons L (tl V1506))))) (true V1506)))

(defun shen.aritycheck (V1509 V1510) (cond ((and (cons? V1510) (and (cons? (hd V1510)) (and (cons? (tl (hd V1510))) (and (= () (tl (tl (hd V1510)))) (= () (tl V1510)))))) (do (shen.aritycheck-action (hd (tl (hd V1510)))) (shen.aritycheck-name V1509 (arity V1509) (length (hd (hd V1510)))))) ((and (cons? V1510) (and (cons? (hd V1510)) (and (cons? (tl (hd V1510))) (and (= () (tl (tl (hd V1510)))) (and (cons? (tl V1510)) (and (cons? (hd (tl V1510))) (and (cons? (tl (hd (tl V1510)))) (= () (tl (tl (hd (tl V1510)))))))))))) (if (= (length (hd (hd V1510))) (length (hd (hd (tl V1510))))) (do (shen.aritycheck-action (hd (tl (hd V1510)))) (shen.aritycheck V1509 (tl V1510))) (simple-error (cn "arity error in " (shen.app V1509 "
" shen.a))))) (true (shen.f_error shen.aritycheck))))

(defun shen.aritycheck-name (V1523 V1524 V1525) (cond ((= -1 V1524) V1525) ((= V1525 V1524) V1525) (true (do (shen.prhush (cn "
warning: changing the arity of " (shen.app V1523 " can cause errors.
" shen.a)) (stoutput)) V1525))))

(defun shen.aritycheck-action (V1531) (cond ((cons? V1531) (do (shen.aah (hd V1531) (tl V1531)) (for-each (lambda Y (shen.aritycheck-action Y)) V1531))) (true shen.skip)))

(defun shen.aah (V1534 V1535) (let Arity (arity V1534) (let Len (length V1535) (if (and (> Arity -1) (> Len Arity)) (shen.prhush (cn "warning: " (shen.app V1534 (cn " might not like " (shen.app Len (cn " argument" (shen.app (if (> Len 1) "s" "") ".
" shen.a)) shen.a)) shen.a)) (stoutput)) shen.skip))))

(defun shen.abstract_rule (V1537) (cond ((and (cons? V1537) (and (cons? (tl V1537)) (= () (tl (tl V1537))))) (shen.abstraction_build (hd V1537) (hd (tl V1537)))) (true (shen.f_error shen.abstract_rule))))

(defun shen.abstraction_build (V1540 V1541) (cond ((= () V1540) V1541) ((cons? V1540) (cons /. (cons (hd V1540) (cons (shen.abstraction_build (tl V1540) V1541) ())))) (true (shen.f_error shen.abstraction_build))))

(defun shen.parameters (V1543) (cond ((= 0 V1543) ()) (true (cons (gensym V) (shen.parameters (- V1543 1))))))

(defun shen.application_build (V1546 V1547) (cond ((= () V1546) V1547) ((cons? V1546) (shen.application_build (tl V1546) (cons V1547 (cons (hd V1546) ())))) (true (shen.f_error shen.application_build))))

(defun shen.compile_to_kl (V1550 V1551) (cond ((and (cons? V1551) (and (cons? (tl V1551)) (= () (tl (tl V1551))))) (let Arity (shen.store-arity V1550 (length (hd V1551))) (let Reduce (map (lambda X (shen.reduce X)) (hd (tl V1551))) (let CondExpression (shen.cond-expression V1550 (hd V1551) Reduce) (let TypeTable (if (value shen.*optimise*) (shen.typextable (shen.get-type V1550) (hd V1551)) shen.skip) (let TypedCondExpression (if (value shen.*optimise*) (shen.assign-types (hd V1551) TypeTable CondExpression) CondExpression) (cons defun (cons V1550 (cons (hd V1551) (cons TypedCondExpression ())))))))))) (true (shen.f_error shen.compile_to_kl))))

(defun shen.get-type (V1557) (cond ((cons? V1557) shen.skip) (true (let FType (assoc V1557 (value shen.*signedfuncs*)) (if (empty? FType) shen.skip (tl FType))))))

(defun shen.typextable (V1568 V1569) (cond ((and (cons? V1568) (and (cons? (tl V1568)) (and (= --> (hd (tl V1568))) (and (cons? (tl (tl V1568))) (and (= () (tl (tl (tl V1568)))) (cons? V1569)))))) (if (variable? (hd V1568)) (shen.typextable (hd (tl (tl V1568))) (tl V1569)) (cons (cons (hd V1569) (hd V1568)) (shen.typextable (hd (tl (tl V1568))) (tl V1569))))) (true ())))

(defun shen.assign-types (V1573 V1574 V1575) (cond ((and (cons? V1575) (and (= let (hd V1575)) (and (cons? (tl V1575)) (and (cons? (tl (tl V1575))) (and (cons? (tl (tl (tl V1575)))) (= () (tl (tl (tl (tl V1575)))))))))) (cons let (cons (hd (tl V1575)) (cons (shen.assign-types V1573 V1574 (hd (tl (tl V1575)))) (cons (shen.assign-types (cons (hd (tl V1575)) V1573) V1574 (hd (tl (tl (tl V1575))))) ()))))) ((and (cons? V1575) (and (= lambda (hd V1575)) (and (cons? (tl V1575)) (and (cons? (tl (tl V1575))) (= () (tl (tl (tl V1575)))))))) (cons lambda (cons (hd (tl V1575)) (cons (shen.assign-types (cons (hd (tl V1575)) V1573) V1574 (hd (tl (tl V1575)))) ())))) ((and (cons? V1575) (= cond (hd V1575))) (cons cond (map (lambda Y (cons (shen.assign-types V1573 V1574 (hd Y)) (cons (shen.assign-types V1573 V1574 (hd (tl Y))) ()))) (tl V1575)))) ((cons? V1575) (let NewTable (shen.typextable (shen.get-type (hd V1575)) (tl V1575)) (cons (hd V1575) (map (lambda Y (shen.assign-types V1573 (append V1574 NewTable) Y)) (tl V1575))))) (true (let AtomType (assoc V1575 V1574) (if (cons? AtomType) (cons type (cons V1575 (cons (tl AtomType) ()))) (if (element? V1575 V1573) V1575 (shen.atom-type V1575)))))))

(defun shen.atom-type (V1577) (if (string? V1577) (cons type (cons V1577 (cons string ()))) (if (number? V1577) (cons type (cons V1577 (cons number ()))) (if (boolean? V1577) (cons type (cons V1577 (cons boolean ()))) (if (symbol? V1577) (cons type (cons V1577 (cons symbol ()))) V1577)))))

(defun shen.store-arity (V1582 V1583) (cond ((value shen.*installing-kl*) shen.skip) (true (put V1582 arity V1583 (value *property-vector*)))))

(defun shen.reduce (V1585) (do (set shen.*teststack* ()) (let Result (shen.reduce_help V1585) (cons (cons : (cons shen.tests (reverse (value shen.*teststack*)))) (cons Result ())))))

(defun shen.reduce_help (V1587) (cond ((and (cons? V1587) (and (cons? (hd V1587)) (and (= /. (hd (hd V1587))) (and (cons? (tl (hd V1587))) (and (cons? (hd (tl (hd V1587)))) (and (= cons (hd (hd (tl (hd V1587))))) (and (cons? (tl (hd (tl (hd V1587))))) (and (cons? (tl (tl (hd (tl (hd V1587)))))) (and (= () (tl (tl (tl (hd (tl (hd V1587))))))) (and (cons? (tl (tl (hd V1587)))) (and (= () (tl (tl (tl (hd V1587))))) (and (cons? (tl V1587)) (= () (tl (tl V1587))))))))))))))) (do (shen.add_test (cons cons? (tl V1587))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1587))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1587)))))) (cons (shen.ebr (hd (tl V1587)) (hd (tl (hd V1587))) (hd (tl (tl (hd V1587))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hd (tl V1587)) ())) (cons (cons tl (tl V1587)) ())) (shen.reduce_help Application))))) ((and (cons? V1587) (and (cons? (hd V1587)) (and (= /. (hd (hd V1587))) (and (cons? (tl (hd V1587))) (and (cons? (hd (tl (hd V1587)))) (and (= @p (hd (hd (tl (hd V1587))))) (and (cons? (tl (hd (tl (hd V1587))))) (and (cons? (tl (tl (hd (tl (hd V1587)))))) (and (= () (tl (tl (tl (hd (tl (hd V1587))))))) (and (cons? (tl (tl (hd V1587)))) (and (= () (tl (tl (tl (hd V1587))))) (and (cons? (tl V1587)) (= () (tl (tl V1587))))))))))))))) (do (shen.add_test (cons tuple? (tl V1587))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1587))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1587)))))) (cons (shen.ebr (hd (tl V1587)) (hd (tl (hd V1587))) (hd (tl (tl (hd V1587))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons fst (tl V1587)) ())) (cons (cons snd (tl V1587)) ())) (shen.reduce_help Application))))) ((and (cons? V1587) (and (cons? (hd V1587)) (and (= /. (hd (hd V1587))) (and (cons? (tl (hd V1587))) (and (cons? (hd (tl (hd V1587)))) (and (= @v (hd (hd (tl (hd V1587))))) (and (cons? (tl (hd (tl (hd V1587))))) (and (cons? (tl (tl (hd (tl (hd V1587)))))) (and (= () (tl (tl (tl (hd (tl (hd V1587))))))) (and (cons? (tl (tl (hd V1587)))) (and (= () (tl (tl (tl (hd V1587))))) (and (cons? (tl V1587)) (= () (tl (tl V1587))))))))))))))) (do (shen.add_test (cons shen.+vector? (tl V1587))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1587))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1587)))))) (cons (shen.ebr (hd (tl V1587)) (hd (tl (hd V1587))) (hd (tl (tl (hd V1587))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hdv (tl V1587)) ())) (cons (cons tlv (tl V1587)) ())) (shen.reduce_help Application))))) ((and (cons? V1587) (and (cons? (hd V1587)) (and (= /. (hd (hd V1587))) (and (cons? (tl (hd V1587))) (and (cons? (hd (tl (hd V1587)))) (and (= @s (hd (hd (tl (hd V1587))))) (and (cons? (tl (hd (tl (hd V1587))))) (and (cons? (tl (tl (hd (tl (hd V1587)))))) (and (= () (tl (tl (tl (hd (tl (hd V1587))))))) (and (cons? (tl (tl (hd V1587)))) (and (= () (tl (tl (tl (hd V1587))))) (and (cons? (tl V1587)) (= () (tl (tl V1587))))))))))))))) (do (shen.add_test (cons shen.+string? (tl V1587))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1587))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1587)))))) (cons (shen.ebr (hd (tl V1587)) (hd (tl (hd V1587))) (hd (tl (tl (hd V1587))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons pos (cons (hd (tl V1587)) (cons 0 ()))) ())) (cons (cons tlstr (tl V1587)) ())) (shen.reduce_help Application))))) ((and (cons? V1587) (and (cons? (hd V1587)) (and (= /. (hd (hd V1587))) (and (cons? (tl (hd V1587))) (and (cons? (tl (tl (hd V1587)))) (and (= () (tl (tl (tl (hd V1587))))) (and (cons? (tl V1587)) (and (= () (tl (tl V1587))) (not (variable? (hd (tl (hd V1587))))))))))))) (do (shen.add_test (cons = (cons (hd (tl (hd V1587))) (tl V1587)))) (shen.reduce_help (hd (tl (tl (hd V1587))))))) ((and (cons? V1587) (and (cons? (hd V1587)) (and (= /. (hd (hd V1587))) (and (cons? (tl (hd V1587))) (and (cons? (tl (tl (hd V1587)))) (and (= () (tl (tl (tl (hd V1587))))) (and (cons? (tl V1587)) (= () (tl (tl V1587)))))))))) (shen.reduce_help (shen.ebr (hd (tl V1587)) (hd (tl (hd V1587))) (hd (tl (tl (hd V1587))))))) ((and (cons? V1587) (and (= where (hd V1587)) (and (cons? (tl V1587)) (and (cons? (tl (tl V1587))) (= () (tl (tl (tl V1587)))))))) (do (shen.add_test (hd (tl V1587))) (shen.reduce_help (hd (tl (tl V1587)))))) ((and (cons? V1587) (and (cons? (tl V1587)) (= () (tl (tl V1587))))) (let Z (shen.reduce_help (hd V1587)) (if (= (hd V1587) Z) V1587 (shen.reduce_help (cons Z (tl V1587)))))) (true V1587)))

(defun shen.+string? (V1589) (cond ((= "" V1589) false) (true (string? V1589))))

(defun shen.+vector? (V1591) (and (absvector? V1591) (> (<-address V1591 0) 0)))

(defun shen.ebr (V1605 V1606 V1607) (cond ((= V1607 V1606) V1605) ((and (cons? V1607) (and (= /. (hd V1607)) (and (cons? (tl V1607)) (and (cons? (tl (tl V1607))) (and (= () (tl (tl (tl V1607)))) (> (occurrences V1606 (hd (tl V1607))) 0)))))) V1607) ((and (cons? V1607) (and (= lambda (hd V1607)) (and (cons? (tl V1607)) (and (cons? (tl (tl V1607))) (and (= () (tl (tl (tl V1607)))) (> (occurrences V1606 (hd (tl V1607))) 0)))))) V1607) ((and (cons? V1607) (and (= let (hd V1607)) (and (cons? (tl V1607)) (and (cons? (tl (tl V1607))) (and (cons? (tl (tl (tl V1607)))) (and (= () (tl (tl (tl (tl V1607))))) (= (hd (tl V1607)) V1606))))))) (cons let (cons (hd (tl V1607)) (cons (shen.ebr V1605 (hd (tl V1607)) (hd (tl (tl V1607)))) (tl (tl (tl V1607))))))) ((cons? V1607) (cons (shen.ebr V1605 V1606 (hd V1607)) (shen.ebr V1605 V1606 (tl V1607)))) (true V1607)))

(defun shen.add_test (V1609) (set shen.*teststack* (cons V1609 (value shen.*teststack*))))

(defun shen.cond-expression (V1613 V1614 V1615) (let Err (shen.err-condition V1613) (let Cases (shen.case-form V1615 Err) (let EncodeChoices (shen.encode-choices Cases V1613) (shen.cond-form EncodeChoices)))))

(defun shen.cond-form (V1619) (cond ((and (cons? V1619) (and (cons? (hd V1619)) (and (= true (hd (hd V1619))) (and (cons? (tl (hd V1619))) (= () (tl (tl (hd V1619)))))))) (hd (tl (hd V1619)))) (true (cons cond V1619))))

(defun shen.encode-choices (V1624 V1625) (cond ((= () V1624) ()) ((and (cons? V1624) (and (cons? (hd V1624)) (and (= true (hd (hd V1624))) (and (cons? (tl (hd V1624))) (and (cons? (hd (tl (hd V1624)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1624))))) (and (cons? (tl (hd (tl (hd V1624))))) (and (= () (tl (tl (hd (tl (hd V1624)))))) (and (= () (tl (tl (hd V1624)))) (= () (tl V1624))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1624))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (if (value shen.*installing-kl*) (cons shen.sys-error (cons V1625 ())) (cons shen.f_error (cons V1625 ()))) (cons Result ())))) ())))) ())) ())) ((and (cons? V1624) (and (cons? (hd V1624)) (and (= true (hd (hd V1624))) (and (cons? (tl (hd V1624))) (and (cons? (hd (tl (hd V1624)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1624))))) (and (cons? (tl (hd (tl (hd V1624))))) (and (= () (tl (tl (hd (tl (hd V1624)))))) (= () (tl (tl (hd V1624)))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1624))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (shen.cond-form (shen.encode-choices (tl V1624) V1625)) (cons Result ())))) ())))) ())) ())) ((and (cons? V1624) (and (cons? (hd V1624)) (and (cons? (tl (hd V1624))) (and (cons? (hd (tl (hd V1624)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1624))))) (and (cons? (tl (hd (tl (hd V1624))))) (and (= () (tl (tl (hd (tl (hd V1624)))))) (= () (tl (tl (hd V1624))))))))))) (cons (cons true (cons (cons let (cons Freeze (cons (cons freeze (cons (shen.cond-form (shen.encode-choices (tl V1624) V1625)) ())) (cons (cons if (cons (hd (hd V1624)) (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1624))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (cons thaw (cons Freeze ())) (cons Result ())))) ())))) (cons (cons thaw (cons Freeze ())) ())))) ())))) ())) ())) ((and (cons? V1624) (and (cons? (hd V1624)) (and (cons? (tl (hd V1624))) (= () (tl (tl (hd V1624))))))) (cons (hd V1624) (shen.encode-choices (tl V1624) V1625))) (true (shen.f_error shen.encode-choices))))

(defun shen.case-form (V1632 V1633) (cond ((= () V1632) (cons V1633 ())) ((and (cons? V1632) (and (cons? (hd V1632)) (and (cons? (hd (hd V1632))) (and (= : (hd (hd (hd V1632)))) (and (cons? (tl (hd (hd V1632)))) (and (= shen.tests (hd (tl (hd (hd V1632))))) (and (= () (tl (tl (hd (hd V1632))))) (and (cons? (tl (hd V1632))) (and (cons? (hd (tl (hd V1632)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1632))))) (and (cons? (tl (hd (tl (hd V1632))))) (and (= () (tl (tl (hd (tl (hd V1632)))))) (= () (tl (tl (hd V1632)))))))))))))))) (cons (cons true (tl (hd V1632))) (shen.case-form (tl V1632) V1633))) ((and (cons? V1632) (and (cons? (hd V1632)) (and (cons? (hd (hd V1632))) (and (= : (hd (hd (hd V1632)))) (and (cons? (tl (hd (hd V1632)))) (and (= shen.tests (hd (tl (hd (hd V1632))))) (and (= () (tl (tl (hd (hd V1632))))) (and (cons? (tl (hd V1632))) (= () (tl (tl (hd V1632)))))))))))) (cons (cons true (tl (hd V1632))) ())) ((and (cons? V1632) (and (cons? (hd V1632)) (and (cons? (hd (hd V1632))) (and (= : (hd (hd (hd V1632)))) (and (cons? (tl (hd (hd V1632)))) (and (= shen.tests (hd (tl (hd (hd V1632))))) (and (cons? (tl (hd V1632))) (= () (tl (tl (hd V1632))))))))))) (cons (cons (shen.embed-and (tl (tl (hd (hd V1632))))) (tl (hd V1632))) (shen.case-form (tl V1632) V1633))) (true (shen.f_error shen.case-form))))

(defun shen.embed-and (V1635) (cond ((and (cons? V1635) (= () (tl V1635))) (hd V1635)) ((cons? V1635) (cons and (cons (hd V1635) (cons (shen.embed-and (tl V1635)) ())))) (true (shen.f_error shen.embed-and))))

(defun shen.err-condition (V1637) (cons true (cons (cons shen.f_error (cons V1637 ())) ())))

(defun shen.sys-error (V1639) (simple-error (cn "system function " (shen.app V1639 ": unexpected argument
" shen.a))))



