"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun read-char-code (V2352) (read-byte V2352))

(defun read-file-as-bytelist (V2354) (shen.read-file-as-Xlist V2354 (lambda S (read-byte S))))

(defun read-file-as-charlist (V2356) (shen.read-file-as-Xlist V2356 (lambda S (read-char-code S))))

(defun shen.read-file-as-Xlist (V2359 V2360) (let Stream (open V2359 in) (let X (V2360 Stream) (let Xs (shen.read-file-as-Xlist-help Stream V2360 X ()) (let Close (close Stream) (reverse Xs))))))

(defun shen.read-file-as-Xlist-help (V2365 V2366 V2367 V2368) (cond ((= -1 V2367) V2368) (true (shen.read-file-as-Xlist-help V2365 V2366 (V2366 V2365) (cons V2367 V2368)))))

(defun read-file-as-string (V2370) (let Stream (open V2370 in) (shen.rfas-h Stream (read-char-code Stream) "")))

(defun shen.rfas-h (V2374 V2375 V2376) (cond ((= -1 V2375) (do (close V2374) V2376)) (true (shen.rfas-h V2374 (read-char-code V2374) (cn V2376 (n->string V2375))))))

(defun input (V2378) (eval-kl (read V2378)))

(defun input+ (V2381 V2382) (let Mono? (shen.monotype V2381) (let Input (read V2382) (if (= false (shen.typecheck Input (shen.demodulate V2381))) (simple-error (cn "type error: " (shen.app Input (cn " is not of type " (shen.app V2381 "
" shen.r)) shen.r))) (eval-kl Input)))))

(defun shen.monotype (V2384) (cond ((cons? V2384) (map (lambda Z (shen.monotype Z)) V2384)) (true (if (variable? V2384) (simple-error (cn "input+ expects a monotype: not " (shen.app V2384 "
" shen.a))) V2384))))

(defun read (V2386) (hd (shen.read-loop V2386 (read-char-code V2386) ())))

(defun it () (value shen.*it*))

(defun shen.read-loop (V2394 V2395 V2396) (cond ((= 94 V2395) (simple-error "read aborted")) ((= -1 V2395) (if (empty? V2396) (simple-error "error: empty stream") (compile (lambda X (shen.<st_input> X)) V2396 (lambda E E)))) ((shen.terminator? V2395) (let AllChars (append V2396 (cons V2395 ())) (let It (shen.record-it AllChars) (let Read (compile (lambda X (shen.<st_input> X)) AllChars (lambda E shen.nextbyte)) (if (or (= Read shen.nextbyte) (empty? Read)) (shen.read-loop V2394 (read-char-code V2394) AllChars) Read))))) (true (shen.read-loop V2394 (read-char-code V2394) (append V2396 (cons V2395 ()))))))

(defun shen.terminator? (V2398) (element? V2398 (cons 9 (cons 10 (cons 13 (cons 32 (cons 34 (cons 41 (cons 93 ())))))))))

(defun lineread (V2400) (shen.lineread-loop (read-char-code V2400) () V2400))

(defun shen.lineread-loop (V2405 V2406 V2407) (cond ((= -1 V2405) (if (empty? V2406) (simple-error "empty stream") (compile (lambda X (shen.<st_input> X)) V2406 (lambda E E)))) ((= V2405 (shen.hat)) (simple-error "line read aborted")) ((element? V2405 (cons (shen.newline) (cons (shen.carriage-return) ()))) (let Line (compile (lambda X (shen.<st_input> X)) V2406 (lambda E shen.nextline)) (let It (shen.record-it V2406) (if (or (= Line shen.nextline) (empty? Line)) (shen.lineread-loop (read-char-code V2407) (append V2406 (cons V2405 ())) V2407) Line)))) (true (shen.lineread-loop (read-char-code V2407) (append V2406 (cons V2405 ())) V2407))))

(defun shen.record-it (V2409) (let TrimLeft (shen.trim-whitespace V2409) (let TrimRight (shen.trim-whitespace (reverse TrimLeft)) (let Trimmed (reverse TrimRight) (shen.record-it-h Trimmed)))))

(defun shen.trim-whitespace (V2411) (cond ((and (cons? V2411) (element? (hd V2411) (cons 9 (cons 10 (cons 13 (cons 32 ())))))) (shen.trim-whitespace (tl V2411))) (true V2411)))

(defun shen.record-it-h (V2413) (do (set shen.*it* (shen.cn-all (map (lambda X (n->string X)) V2413))) V2413))

(defun shen.cn-all (V2415) (cond ((= () V2415) "") ((cons? V2415) (cn (hd V2415) (shen.cn-all (tl V2415)))) (true (shen.f_error shen.cn-all))))

(defun read-file (V2417) (let Charlist (read-file-as-charlist V2417) (compile (lambda X (shen.<st_input> X)) Charlist (lambda X (shen.read-error X)))))

(defun read-from-string (V2419) (let Ns (map (lambda X (string->n X)) (explode V2419)) (compile (lambda X (shen.<st_input> X)) Ns (lambda X (shen.read-error X)))))

(defun shen.read-error (V2427) (cond ((and (cons? V2427) (and (cons? (hd V2427)) (and (cons? (tl V2427)) (= () (tl (tl V2427)))))) (simple-error (cn "read error here:

 " (shen.app (shen.compress-50 50 (hd V2427)) "
" shen.a)))) (true (simple-error "read error
"))))

(defun shen.compress-50 (V2434 V2435) (cond ((= () V2435) "") ((= 0 V2434) "") ((cons? V2435) (cn (n->string (hd V2435)) (shen.compress-50 (- V2434 1) (tl V2435)))) (true (shen.f_error shen.compress-50))))

(defun shen.<st_input> (V2437) (let YaccParse (let Parse_shen.<lsb> (shen.<lsb> V2437) (if (not (= (fail) Parse_shen.<lsb>)) (let Parse_shen.<st_input1> (shen.<st_input1> Parse_shen.<lsb>) (if (not (= (fail) Parse_shen.<st_input1>)) (let Parse_shen.<rsb> (shen.<rsb> Parse_shen.<st_input1>) (if (not (= (fail) Parse_shen.<rsb>)) (let Parse_shen.<st_input2> (shen.<st_input2> Parse_shen.<rsb>) (if (not (= (fail) Parse_shen.<st_input2>)) (shen.pair (hd Parse_shen.<st_input2>) (cons (macroexpand (shen.cons_form (shen.hdtl Parse_shen.<st_input1>))) (shen.hdtl Parse_shen.<st_input2>))) (fail))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<lrb> (shen.<lrb> V2437) (if (not (= (fail) Parse_shen.<lrb>)) (let Parse_shen.<st_input1> (shen.<st_input1> Parse_shen.<lrb>) (if (not (= (fail) Parse_shen.<st_input1>)) (let Parse_shen.<rrb> (shen.<rrb> Parse_shen.<st_input1>) (if (not (= (fail) Parse_shen.<rrb>)) (let Parse_shen.<st_input2> (shen.<st_input2> Parse_shen.<rrb>) (if (not (= (fail) Parse_shen.<st_input2>)) (shen.pair (hd Parse_shen.<st_input2>) (shen.package-macro (macroexpand (shen.hdtl Parse_shen.<st_input1>)) (shen.hdtl Parse_shen.<st_input2>))) (fail))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<lcurly> (shen.<lcurly> V2437) (if (not (= (fail) Parse_shen.<lcurly>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<lcurly>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons { (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<rcurly> (shen.<rcurly> V2437) (if (not (= (fail) Parse_shen.<rcurly>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<rcurly>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons } (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<bar> (shen.<bar> V2437) (if (not (= (fail) Parse_shen.<bar>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<bar>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons bar! (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<semicolon> (shen.<semicolon> V2437) (if (not (= (fail) Parse_shen.<semicolon>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<semicolon>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons ; (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<colon> (shen.<colon> V2437) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<equal> (shen.<equal> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<equal>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<equal>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons := (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<colon> (shen.<colon> V2437) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<minus> (shen.<minus> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons :- (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<colon> (shen.<colon> V2437) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons : (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<comma> (shen.<comma> V2437) (if (not (= (fail) Parse_shen.<comma>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<comma>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons (intern ",") (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<comment> (shen.<comment> V2437) (if (not (= (fail) Parse_shen.<comment>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<comment>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<atom> (shen.<atom> V2437) (if (not (= (fail) Parse_shen.<atom>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<atom>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons (macroexpand (shen.hdtl Parse_shen.<atom>)) (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<whitespaces> (shen.<whitespaces> V2437) (if (not (= (fail) Parse_shen.<whitespaces>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<whitespaces>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2437) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.<lsb> (V2439) (if (and (cons? (hd V2439)) (= 91 (hd (hd V2439)))) (shen.pair (hd (shen.pair (tl (hd V2439)) (shen.hdtl V2439))) shen.skip) (fail)))

(defun shen.<rsb> (V2441) (if (and (cons? (hd V2441)) (= 93 (hd (hd V2441)))) (shen.pair (hd (shen.pair (tl (hd V2441)) (shen.hdtl V2441))) shen.skip) (fail)))

(defun shen.<lcurly> (V2443) (if (and (cons? (hd V2443)) (= 123 (hd (hd V2443)))) (shen.pair (hd (shen.pair (tl (hd V2443)) (shen.hdtl V2443))) shen.skip) (fail)))

(defun shen.<rcurly> (V2445) (if (and (cons? (hd V2445)) (= 125 (hd (hd V2445)))) (shen.pair (hd (shen.pair (tl (hd V2445)) (shen.hdtl V2445))) shen.skip) (fail)))

(defun shen.<bar> (V2447) (if (and (cons? (hd V2447)) (= 124 (hd (hd V2447)))) (shen.pair (hd (shen.pair (tl (hd V2447)) (shen.hdtl V2447))) shen.skip) (fail)))

(defun shen.<semicolon> (V2449) (if (and (cons? (hd V2449)) (= 59 (hd (hd V2449)))) (shen.pair (hd (shen.pair (tl (hd V2449)) (shen.hdtl V2449))) shen.skip) (fail)))

(defun shen.<colon> (V2451) (if (and (cons? (hd V2451)) (= 58 (hd (hd V2451)))) (shen.pair (hd (shen.pair (tl (hd V2451)) (shen.hdtl V2451))) shen.skip) (fail)))

(defun shen.<comma> (V2453) (if (and (cons? (hd V2453)) (= 44 (hd (hd V2453)))) (shen.pair (hd (shen.pair (tl (hd V2453)) (shen.hdtl V2453))) shen.skip) (fail)))

(defun shen.<equal> (V2455) (if (and (cons? (hd V2455)) (= 61 (hd (hd V2455)))) (shen.pair (hd (shen.pair (tl (hd V2455)) (shen.hdtl V2455))) shen.skip) (fail)))

(defun shen.<minus> (V2457) (if (and (cons? (hd V2457)) (= 45 (hd (hd V2457)))) (shen.pair (hd (shen.pair (tl (hd V2457)) (shen.hdtl V2457))) shen.skip) (fail)))

(defun shen.<lrb> (V2459) (if (and (cons? (hd V2459)) (= 40 (hd (hd V2459)))) (shen.pair (hd (shen.pair (tl (hd V2459)) (shen.hdtl V2459))) shen.skip) (fail)))

(defun shen.<rrb> (V2461) (if (and (cons? (hd V2461)) (= 41 (hd (hd V2461)))) (shen.pair (hd (shen.pair (tl (hd V2461)) (shen.hdtl V2461))) shen.skip) (fail)))

(defun shen.<atom> (V2463) (let YaccParse (let Parse_shen.<str> (shen.<str> V2463) (if (not (= (fail) Parse_shen.<str>)) (shen.pair (hd Parse_shen.<str>) (shen.control-chars (shen.hdtl Parse_shen.<str>))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<number> (shen.<number> V2463) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (shen.hdtl Parse_shen.<number>)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<sym> (shen.<sym> V2463) (if (not (= (fail) Parse_shen.<sym>)) (shen.pair (hd Parse_shen.<sym>) (if (= (shen.hdtl Parse_shen.<sym>) "<>") (cons vector (cons 0 ())) (intern (shen.hdtl Parse_shen.<sym>)))) (fail))) YaccParse)) YaccParse)))

(defun shen.control-chars (V2465) (cond ((= () V2465) "") ((and (cons? V2465) (and (= "c" (hd V2465)) (and (cons? (tl V2465)) (= "#" (hd (tl V2465)))))) (let CodePoint (shen.code-point (tl (tl V2465))) (let AfterCodePoint (shen.after-codepoint (tl (tl V2465))) (@s (n->string (shen.decimalise CodePoint)) (shen.control-chars AfterCodePoint))))) ((cons? V2465) (@s (hd V2465) (shen.control-chars (tl V2465)))) (true (shen.f_error shen.control-chars))))

(defun shen.code-point (V2469) (cond ((and (cons? V2469) (= ";" (hd V2469))) "") ((and (cons? V2469) (element? (hd V2469) (cons "0" (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" ()))))))))))))) (cons (hd V2469) (shen.code-point (tl V2469)))) (true (simple-error (cn "code point parse error " (shen.app V2469 "
" shen.a))))))

(defun shen.after-codepoint (V2475) (cond ((= () V2475) ()) ((and (cons? V2475) (= ";" (hd V2475))) (tl V2475)) ((cons? V2475) (shen.after-codepoint (tl V2475))) (true (shen.f_error shen.after-codepoint))))

(defun shen.decimalise (V2477) (shen.pre (reverse (shen.digits->integers V2477)) 0))

(defun shen.digits->integers (V2483) (cond ((and (cons? V2483) (= "0" (hd V2483))) (cons 0 (shen.digits->integers (tl V2483)))) ((and (cons? V2483) (= "1" (hd V2483))) (cons 1 (shen.digits->integers (tl V2483)))) ((and (cons? V2483) (= "2" (hd V2483))) (cons 2 (shen.digits->integers (tl V2483)))) ((and (cons? V2483) (= "3" (hd V2483))) (cons 3 (shen.digits->integers (tl V2483)))) ((and (cons? V2483) (= "4" (hd V2483))) (cons 4 (shen.digits->integers (tl V2483)))) ((and (cons? V2483) (= "5" (hd V2483))) (cons 5 (shen.digits->integers (tl V2483)))) ((and (cons? V2483) (= "6" (hd V2483))) (cons 6 (shen.digits->integers (tl V2483)))) ((and (cons? V2483) (= "7" (hd V2483))) (cons 7 (shen.digits->integers (tl V2483)))) ((and (cons? V2483) (= "8" (hd V2483))) (cons 8 (shen.digits->integers (tl V2483)))) ((and (cons? V2483) (= "9" (hd V2483))) (cons 9 (shen.digits->integers (tl V2483)))) (true ())))

(defun shen.<sym> (V2485) (let Parse_shen.<alpha> (shen.<alpha> V2485) (if (not (= (fail) Parse_shen.<alpha>)) (let Parse_shen.<alphanums> (shen.<alphanums> Parse_shen.<alpha>) (if (not (= (fail) Parse_shen.<alphanums>)) (shen.pair (hd Parse_shen.<alphanums>) (@s (shen.hdtl Parse_shen.<alpha>) (shen.hdtl Parse_shen.<alphanums>))) (fail))) (fail))))

(defun shen.<alphanums> (V2487) (let YaccParse (let Parse_shen.<alphanum> (shen.<alphanum> V2487) (if (not (= (fail) Parse_shen.<alphanum>)) (let Parse_shen.<alphanums> (shen.<alphanums> Parse_shen.<alphanum>) (if (not (= (fail) Parse_shen.<alphanums>)) (shen.pair (hd Parse_shen.<alphanums>) (@s (shen.hdtl Parse_shen.<alphanum>) (shen.hdtl Parse_shen.<alphanums>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2487) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) "") (fail))) YaccParse)))

(defun shen.<alphanum> (V2489) (let YaccParse (let Parse_shen.<alpha> (shen.<alpha> V2489) (if (not (= (fail) Parse_shen.<alpha>)) (shen.pair (hd Parse_shen.<alpha>) (shen.hdtl Parse_shen.<alpha>)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<num> (shen.<num> V2489) (if (not (= (fail) Parse_shen.<num>)) (shen.pair (hd Parse_shen.<num>) (shen.hdtl Parse_shen.<num>)) (fail))) YaccParse)))

(defun shen.<num> (V2491) (if (cons? (hd V2491)) (let Parse_Char (hd (hd V2491)) (if (shen.numbyte? Parse_Char) (shen.pair (hd (shen.pair (tl (hd V2491)) (shen.hdtl V2491))) (n->string Parse_Char)) (fail))) (fail)))

(defun shen.numbyte? (V2497) (cond ((= 48 V2497) true) ((= 49 V2497) true) ((= 50 V2497) true) ((= 51 V2497) true) ((= 52 V2497) true) ((= 53 V2497) true) ((= 54 V2497) true) ((= 55 V2497) true) ((= 56 V2497) true) ((= 57 V2497) true) (true false)))

(defun shen.<alpha> (V2499) (if (cons? (hd V2499)) (let Parse_Char (hd (hd V2499)) (if (shen.symbol-code? Parse_Char) (shen.pair (hd (shen.pair (tl (hd V2499)) (shen.hdtl V2499))) (n->string Parse_Char)) (fail))) (fail)))

(defun shen.symbol-code? (V2501) (or (= V2501 126) (or (and (> V2501 94) (< V2501 123)) (or (and (> V2501 59) (< V2501 91)) (or (and (> V2501 41) (and (< V2501 58) (not (= V2501 44)))) (or (and (> V2501 34) (< V2501 40)) (= V2501 33)))))))

(defun shen.<str> (V2503) (let Parse_shen.<dbq> (shen.<dbq> V2503) (if (not (= (fail) Parse_shen.<dbq>)) (let Parse_shen.<strcontents> (shen.<strcontents> Parse_shen.<dbq>) (if (not (= (fail) Parse_shen.<strcontents>)) (let Parse_shen.<dbq> (shen.<dbq> Parse_shen.<strcontents>) (if (not (= (fail) Parse_shen.<dbq>)) (shen.pair (hd Parse_shen.<dbq>) (shen.hdtl Parse_shen.<strcontents>)) (fail))) (fail))) (fail))))

(defun shen.<dbq> (V2505) (if (cons? (hd V2505)) (let Parse_Char (hd (hd V2505)) (if (= Parse_Char 34) (shen.pair (hd (shen.pair (tl (hd V2505)) (shen.hdtl V2505))) Parse_Char) (fail))) (fail)))

(defun shen.<strcontents> (V2507) (let YaccParse (let Parse_shen.<strc> (shen.<strc> V2507) (if (not (= (fail) Parse_shen.<strc>)) (let Parse_shen.<strcontents> (shen.<strcontents> Parse_shen.<strc>) (if (not (= (fail) Parse_shen.<strcontents>)) (shen.pair (hd Parse_shen.<strcontents>) (cons (shen.hdtl Parse_shen.<strc>) (shen.hdtl Parse_shen.<strcontents>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2507) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<byte> (V2509) (if (cons? (hd V2509)) (let Parse_Char (hd (hd V2509)) (shen.pair (hd (shen.pair (tl (hd V2509)) (shen.hdtl V2509))) (n->string Parse_Char))) (fail)))

(defun shen.<strc> (V2511) (if (cons? (hd V2511)) (let Parse_Char (hd (hd V2511)) (if (not (= Parse_Char 34)) (shen.pair (hd (shen.pair (tl (hd V2511)) (shen.hdtl V2511))) (n->string Parse_Char)) (fail))) (fail)))

(defun shen.<number> (V2513) (let YaccParse (let Parse_shen.<minus> (shen.<minus> V2513) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<number> (shen.<number> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (- 0 (shen.hdtl Parse_shen.<number>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<plus> (shen.<plus> V2513) (if (not (= (fail) Parse_shen.<plus>)) (let Parse_shen.<number> (shen.<number> Parse_shen.<plus>) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (shen.hdtl Parse_shen.<number>)) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<predigits> (shen.<predigits> V2513) (if (not (= (fail) Parse_shen.<predigits>)) (let Parse_shen.<stop> (shen.<stop> Parse_shen.<predigits>) (if (not (= (fail) Parse_shen.<stop>)) (let Parse_shen.<postdigits> (shen.<postdigits> Parse_shen.<stop>) (if (not (= (fail) Parse_shen.<postdigits>)) (let Parse_shen.<E> (shen.<E> Parse_shen.<postdigits>) (if (not (= (fail) Parse_shen.<E>)) (let Parse_shen.<log10> (shen.<log10> Parse_shen.<E>) (if (not (= (fail) Parse_shen.<log10>)) (shen.pair (hd Parse_shen.<log10>) (* (shen.expt 10 (shen.hdtl Parse_shen.<log10>)) (+ (shen.pre (reverse (shen.hdtl Parse_shen.<predigits>)) 0) (shen.post (shen.hdtl Parse_shen.<postdigits>) 1)))) (fail))) (fail))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<digits> (shen.<digits> V2513) (if (not (= (fail) Parse_shen.<digits>)) (let Parse_shen.<E> (shen.<E> Parse_shen.<digits>) (if (not (= (fail) Parse_shen.<E>)) (let Parse_shen.<log10> (shen.<log10> Parse_shen.<E>) (if (not (= (fail) Parse_shen.<log10>)) (shen.pair (hd Parse_shen.<log10>) (* (shen.expt 10 (shen.hdtl Parse_shen.<log10>)) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<predigits> (shen.<predigits> V2513) (if (not (= (fail) Parse_shen.<predigits>)) (let Parse_shen.<stop> (shen.<stop> Parse_shen.<predigits>) (if (not (= (fail) Parse_shen.<stop>)) (let Parse_shen.<postdigits> (shen.<postdigits> Parse_shen.<stop>) (if (not (= (fail) Parse_shen.<postdigits>)) (shen.pair (hd Parse_shen.<postdigits>) (+ (shen.pre (reverse (shen.hdtl Parse_shen.<predigits>)) 0) (shen.post (shen.hdtl Parse_shen.<postdigits>) 1))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<digits> (shen.<digits> V2513) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.<E> (V2515) (if (and (cons? (hd V2515)) (= 101 (hd (hd V2515)))) (shen.pair (hd (shen.pair (tl (hd V2515)) (shen.hdtl V2515))) shen.skip) (fail)))

(defun shen.<log10> (V2517) (let YaccParse (let Parse_shen.<minus> (shen.<minus> V2517) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<digits> (shen.<digits> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (- 0 (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<digits> (shen.<digits> V2517) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0)) (fail))) YaccParse)))

(defun shen.<plus> (V2519) (if (cons? (hd V2519)) (let Parse_Char (hd (hd V2519)) (if (= Parse_Char 43) (shen.pair (hd (shen.pair (tl (hd V2519)) (shen.hdtl V2519))) Parse_Char) (fail))) (fail)))

(defun shen.<stop> (V2521) (if (cons? (hd V2521)) (let Parse_Char (hd (hd V2521)) (if (= Parse_Char 46) (shen.pair (hd (shen.pair (tl (hd V2521)) (shen.hdtl V2521))) Parse_Char) (fail))) (fail)))

(defun shen.<predigits> (V2523) (let YaccParse (let Parse_shen.<digits> (shen.<digits> V2523) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.hdtl Parse_shen.<digits>)) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2523) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<postdigits> (V2525) (let Parse_shen.<digits> (shen.<digits> V2525) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.hdtl Parse_shen.<digits>)) (fail))))

(defun shen.<digits> (V2527) (let YaccParse (let Parse_shen.<digit> (shen.<digit> V2527) (if (not (= (fail) Parse_shen.<digit>)) (let Parse_shen.<digits> (shen.<digits> Parse_shen.<digit>) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (cons (shen.hdtl Parse_shen.<digit>) (shen.hdtl Parse_shen.<digits>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<digit> (shen.<digit> V2527) (if (not (= (fail) Parse_shen.<digit>)) (shen.pair (hd Parse_shen.<digit>) (cons (shen.hdtl Parse_shen.<digit>) ())) (fail))) YaccParse)))

(defun shen.<digit> (V2529) (if (cons? (hd V2529)) (let Parse_X (hd (hd V2529)) (if (shen.numbyte? Parse_X) (shen.pair (hd (shen.pair (tl (hd V2529)) (shen.hdtl V2529))) (shen.byte->digit Parse_X)) (fail))) (fail)))

(defun shen.byte->digit (V2531) (cond ((= 48 V2531) 0) ((= 49 V2531) 1) ((= 50 V2531) 2) ((= 51 V2531) 3) ((= 52 V2531) 4) ((= 53 V2531) 5) ((= 54 V2531) 6) ((= 55 V2531) 7) ((= 56 V2531) 8) ((= 57 V2531) 9) (true (shen.f_error shen.byte->digit))))

(defun shen.pre (V2536 V2537) (cond ((= () V2536) 0) ((cons? V2536) (+ (* (shen.expt 10 V2537) (hd V2536)) (shen.pre (tl V2536) (+ V2537 1)))) (true (shen.f_error shen.pre))))

(defun shen.post (V2542 V2543) (cond ((= () V2542) 0) ((cons? V2542) (+ (* (shen.expt 10 (- 0 V2543)) (hd V2542)) (shen.post (tl V2542) (+ V2543 1)))) (true (shen.f_error shen.post))))

(defun shen.expt (V2548 V2549) (cond ((= 0 V2549) 1) ((> V2549 0) (* V2548 (shen.expt V2548 (- V2549 1)))) (true (* 1 (/ (shen.expt V2548 (+ V2549 1)) V2548)))))

(defun shen.<st_input1> (V2551) (let Parse_shen.<st_input> (shen.<st_input> V2551) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))))

(defun shen.<st_input2> (V2553) (let Parse_shen.<st_input> (shen.<st_input> V2553) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))))

(defun shen.<comment> (V2555) (let YaccParse (let Parse_shen.<singleline> (shen.<singleline> V2555) (if (not (= (fail) Parse_shen.<singleline>)) (shen.pair (hd Parse_shen.<singleline>) shen.skip) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<multiline> (shen.<multiline> V2555) (if (not (= (fail) Parse_shen.<multiline>)) (shen.pair (hd Parse_shen.<multiline>) shen.skip) (fail))) YaccParse)))

(defun shen.<singleline> (V2557) (let Parse_shen.<backslash> (shen.<backslash> V2557) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<backslash> (shen.<backslash> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<anysingle> (shen.<anysingle> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<anysingle>)) (let Parse_shen.<return> (shen.<return> Parse_shen.<anysingle>) (if (not (= (fail) Parse_shen.<return>)) (shen.pair (hd Parse_shen.<return>) shen.skip) (fail))) (fail))) (fail))) (fail))))

(defun shen.<backslash> (V2559) (if (and (cons? (hd V2559)) (= 92 (hd (hd V2559)))) (shen.pair (hd (shen.pair (tl (hd V2559)) (shen.hdtl V2559))) shen.skip) (fail)))

(defun shen.<anysingle> (V2561) (let YaccParse (let Parse_shen.<non-return> (shen.<non-return> V2561) (if (not (= (fail) Parse_shen.<non-return>)) (let Parse_shen.<anysingle> (shen.<anysingle> Parse_shen.<non-return>) (if (not (= (fail) Parse_shen.<anysingle>)) (shen.pair (hd Parse_shen.<anysingle>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2561) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) shen.skip) (fail))) YaccParse)))

(defun shen.<non-return> (V2563) (if (cons? (hd V2563)) (let Parse_X (hd (hd V2563)) (if (not (element? Parse_X (cons 10 (cons 13 ())))) (shen.pair (hd (shen.pair (tl (hd V2563)) (shen.hdtl V2563))) shen.skip) (fail))) (fail)))

(defun shen.<return> (V2565) (if (cons? (hd V2565)) (let Parse_X (hd (hd V2565)) (if (element? Parse_X (cons 10 (cons 13 ()))) (shen.pair (hd (shen.pair (tl (hd V2565)) (shen.hdtl V2565))) shen.skip) (fail))) (fail)))

(defun shen.<multiline> (V2567) (let Parse_shen.<backslash> (shen.<backslash> V2567) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<times> (shen.<times> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<times>)) (let Parse_shen.<anymulti> (shen.<anymulti> Parse_shen.<times>) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail))) (fail))) (fail))))

(defun shen.<times> (V2569) (if (and (cons? (hd V2569)) (= 42 (hd (hd V2569)))) (shen.pair (hd (shen.pair (tl (hd V2569)) (shen.hdtl V2569))) shen.skip) (fail)))

(defun shen.<anymulti> (V2571) (let YaccParse (let Parse_shen.<comment> (shen.<comment> V2571) (if (not (= (fail) Parse_shen.<comment>)) (let Parse_shen.<anymulti> (shen.<anymulti> Parse_shen.<comment>) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<times> (shen.<times> V2571) (if (not (= (fail) Parse_shen.<times>)) (let Parse_shen.<backslash> (shen.<backslash> Parse_shen.<times>) (if (not (= (fail) Parse_shen.<backslash>)) (shen.pair (hd Parse_shen.<backslash>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (if (cons? (hd V2571)) (let Parse_X (hd (hd V2571)) (let Parse_shen.<anymulti> (shen.<anymulti> (shen.pair (tl (hd V2571)) (shen.hdtl V2571))) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail)))) (fail)) YaccParse)) YaccParse)))

(defun shen.<whitespaces> (V2573) (let YaccParse (let Parse_shen.<whitespace> (shen.<whitespace> V2573) (if (not (= (fail) Parse_shen.<whitespace>)) (let Parse_shen.<whitespaces> (shen.<whitespaces> Parse_shen.<whitespace>) (if (not (= (fail) Parse_shen.<whitespaces>)) (shen.pair (hd Parse_shen.<whitespaces>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<whitespace> (shen.<whitespace> V2573) (if (not (= (fail) Parse_shen.<whitespace>)) (shen.pair (hd Parse_shen.<whitespace>) shen.skip) (fail))) YaccParse)))

(defun shen.<whitespace> (V2575) (if (cons? (hd V2575)) (let Parse_X (hd (hd V2575)) (if (let Parse_Case Parse_X (or (= Parse_Case 32) (or (= Parse_Case 13) (or (= Parse_Case 10) (= Parse_Case 9))))) (shen.pair (hd (shen.pair (tl (hd V2575)) (shen.hdtl V2575))) shen.skip) (fail))) (fail)))

(defun shen.cons_form (V2577) (cond ((= () V2577) ()) ((and (cons? V2577) (and (cons? (tl V2577)) (and (cons? (tl (tl V2577))) (and (= () (tl (tl (tl V2577)))) (= (hd (tl V2577)) bar!))))) (cons cons (cons (hd V2577) (tl (tl V2577))))) ((cons? V2577) (cons cons (cons (hd V2577) (cons (shen.cons_form (tl V2577)) ())))) (true (shen.f_error shen.cons_form))))

(defun shen.package-macro (V2582 V2583) (cond ((and (cons? V2582) (and (= $ (hd V2582)) (and (cons? (tl V2582)) (= () (tl (tl V2582)))))) (append (explode (hd (tl V2582))) V2583)) ((and (cons? V2582) (and (= package (hd V2582)) (and (cons? (tl V2582)) (and (= null (hd (tl V2582))) (cons? (tl (tl V2582))))))) (append (tl (tl (tl V2582))) V2583)) ((and (cons? V2582) (and (= package (hd V2582)) (and (cons? (tl V2582)) (cons? (tl (tl V2582)))))) (let ListofExceptions (shen.eval-without-macros (hd (tl (tl V2582)))) (let External (shen.record-exceptions ListofExceptions (hd (tl V2582))) (let PackageNameDot (intern (cn (str (hd (tl V2582))) ".")) (let ExpPackageNameDot (explode PackageNameDot) (let Packaged (shen.packageh PackageNameDot ListofExceptions (tl (tl (tl V2582))) ExpPackageNameDot) (let Internal (shen.record-internal (hd (tl V2582)) (shen.internal-symbols ExpPackageNameDot Packaged)) (append Packaged V2583)))))))) (true (cons V2582 V2583))))

(defun shen.record-exceptions (V2586 V2587) (let CurrExceptions (get/or V2587 shen.external-symbols (freeze ()) (value *property-vector*)) (let AllExceptions (union V2586 CurrExceptions) (put V2587 shen.external-symbols AllExceptions (value *property-vector*)))))

(defun shen.record-internal (V2590 V2591) (put V2590 shen.internal-symbols (union V2591 (get/or V2590 shen.internal-symbols (freeze ()) (value *property-vector*))) (value *property-vector*)))

(defun shen.internal-symbols (V2602 V2603) (cond ((and (symbol? V2603) (shen.prefix? V2602 (explode V2603))) (cons V2603 ())) ((cons? V2603) (union (shen.internal-symbols V2602 (hd V2603)) (shen.internal-symbols V2602 (tl V2603)))) (true ())))

(defun shen.packageh (V2620 V2621 V2622 V2623) (cond ((cons? V2622) (cons (shen.packageh V2620 V2621 (hd V2622) V2623) (shen.packageh V2620 V2621 (tl V2622) V2623))) ((or (shen.sysfunc? V2622) (or (variable? V2622) (or (element? V2622 V2621) (or (shen.doubleunderline? V2622) (shen.singleunderline? V2622))))) V2622) ((and (symbol? V2622) (let ExplodeX (explode V2622) (and (not (shen.prefix? (cons "s" (cons "h" (cons "e" (cons "n" (cons "." ()))))) ExplodeX)) (not (shen.prefix? V2623 ExplodeX))))) (concat V2620 V2622)) (true V2622)))



