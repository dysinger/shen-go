"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.typecheck (V3698 V3699) (let Curry (shen.curry V3698) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V3699)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V3701) (cond ((and (cons? V3701) (shen.special? (hd V3701))) (cons (hd V3701) (map (lambda Y (shen.curry Y)) (tl V3701)))) ((and (cons? V3701) (and (cons? (tl V3701)) (shen.extraspecial? (hd V3701)))) V3701) ((and (cons? V3701) (and (= type (hd V3701)) (and (cons? (tl V3701)) (and (cons? (tl (tl V3701))) (= () (tl (tl (tl V3701)))))))) (cons type (cons (shen.curry (hd (tl V3701))) (tl (tl V3701))))) ((and (cons? V3701) (and (cons? (tl V3701)) (cons? (tl (tl V3701))))) (shen.curry (cons (cons (hd V3701) (cons (hd (tl V3701)) ())) (tl (tl V3701))))) ((and (cons? V3701) (and (cons? (tl V3701)) (= () (tl (tl V3701))))) (cons (shen.curry (hd V3701)) (cons (shen.curry (hd (tl V3701))) ()))) (true V3701)))

(defun shen.special? (V3703) (element? V3703 (value shen.*special*)))

(defun shen.extraspecial? (V3705) (element? V3705 (value shen.*extraspecial*)))

(defun shen.t* (V3710 V3711 V3712 V3713) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V3712) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V3712 (freeze (bind Error (shen.errormaxinfs) V3712 V3713))))) (if (= Case false) (let Case (let V3690 (shen.lazyderef V3710 V3712) (if (= fail V3690) (do (shen.incinfs) (cut Throwcontrol V3712 (freeze (shen.prolog-failure V3712 V3713)))) false)) (if (= Case false) (let Case (let V3691 (shen.lazyderef V3710 V3712) (if (cons? V3691) (let X (hd V3691) (let V3692 (shen.lazyderef (tl V3691) V3712) (if (cons? V3692) (let V3693 (shen.lazyderef (hd V3692) V3712) (if (= : V3693) (let V3694 (shen.lazyderef (tl V3692) V3712) (if (cons? V3694) (let A (hd V3694) (let V3695 (shen.lazyderef (tl V3694) V3712) (if (= () V3695) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V3712 (freeze (cut Throwcontrol V3712 (freeze (shen.th* X A V3711 V3712 V3713)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V3712) (do (shen.incinfs) (shen.show V3710 V3711 V3712 (freeze (bind Datatypes (value shen.*datatypes*) V3712 (freeze (shen.udefs* V3710 V3711 Datatypes V3712 V3713))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V3719) (cond ((= + V3719) (set shen.*shen-type-theory-enabled?* true)) ((= - V3719) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V3730 V3731) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V3737 V3738 V3739 V3740 V3741) (let Case (let V3686 (shen.lazyderef V3739 V3740) (if (cons? V3686) (let D (hd V3686) (do (shen.incinfs) (call (cons D (cons V3737 (cons V3738 ()))) V3740 V3741))) false)) (if (= Case false) (let V3687 (shen.lazyderef V3739 V3740) (if (cons? V3687) (let Ds (tl V3687) (do (shen.incinfs) (shen.udefs* V3737 V3738 Ds V3740 V3741))) false)) Case)))

(defun shen.th* (V3747 V3748 V3749 V3750 V3751) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V3747 (cons : (cons V3748 ()))) V3749 V3750 (freeze (fwhen false V3750 V3751)))) (if (= Case false) (let Case (let F (shen.newpv V3750) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V3747 V3750)) V3750 (freeze (bind F (shen.sigf (shen.lazyderef V3747 V3750)) V3750 (freeze (call (cons F (cons V3748 ())) V3750 V3751))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V3747 V3748 V3750 V3751)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V3747 V3748 V3749 V3750 V3751)) (if (= Case false) (let Case (let V3582 (shen.lazyderef V3747 V3750) (if (cons? V3582) (let F (hd V3582) (let V3583 (shen.lazyderef (tl V3582) V3750) (if (= () V3583) (do (shen.incinfs) (shen.th* F (cons --> (cons V3748 ())) V3749 V3750 V3751)) false))) false)) (if (= Case false) (let Case (let V3584 (shen.lazyderef V3747 V3750) (if (cons? V3584) (let F (hd V3584) (let V3585 (shen.lazyderef (tl V3584) V3750) (if (cons? V3585) (let X (hd V3585) (let V3586 (shen.lazyderef (tl V3585) V3750) (if (= () V3586) (let B (shen.newpv V3750) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V3748 ()))) V3749 V3750 (freeze (shen.th* X B V3749 V3750 V3751))))) false))) false))) false)) (if (= Case false) (let Case (let V3587 (shen.lazyderef V3747 V3750) (if (cons? V3587) (let V3588 (shen.lazyderef (hd V3587) V3750) (if (= cons V3588) (let V3589 (shen.lazyderef (tl V3587) V3750) (if (cons? V3589) (let X (hd V3589) (let V3590 (shen.lazyderef (tl V3589) V3750) (if (cons? V3590) (let Y (hd V3590) (let V3591 (shen.lazyderef (tl V3590) V3750) (if (= () V3591) (let V3592 (shen.lazyderef V3748 V3750) (if (cons? V3592) (let V3593 (shen.lazyderef (hd V3592) V3750) (if (= list V3593) (let V3594 (shen.lazyderef (tl V3592) V3750) (if (cons? V3594) (let A (hd V3594) (let V3595 (shen.lazyderef (tl V3594) V3750) (if (= () V3595) (do (shen.incinfs) (shen.th* X A V3749 V3750 (freeze (shen.th* Y (cons list (cons A ())) V3749 V3750 V3751)))) (if (shen.pvar? V3595) (do (shen.bindv V3595 () V3750) (let Result (do (shen.incinfs) (shen.th* X A V3749 V3750 (freeze (shen.th* Y (cons list (cons A ())) V3749 V3750 V3751)))) (do (shen.unbindv V3595 V3750) Result))) false)))) (if (shen.pvar? V3594) (let A (shen.newpv V3750) (do (shen.bindv V3594 (cons A ()) V3750) (let Result (do (shen.incinfs) (shen.th* X A V3749 V3750 (freeze (shen.th* Y (cons list (cons A ())) V3749 V3750 V3751)))) (do (shen.unbindv V3594 V3750) Result)))) false))) (if (shen.pvar? V3593) (do (shen.bindv V3593 list V3750) (let Result (let V3596 (shen.lazyderef (tl V3592) V3750) (if (cons? V3596) (let A (hd V3596) (let V3597 (shen.lazyderef (tl V3596) V3750) (if (= () V3597) (do (shen.incinfs) (shen.th* X A V3749 V3750 (freeze (shen.th* Y (cons list (cons A ())) V3749 V3750 V3751)))) (if (shen.pvar? V3597) (do (shen.bindv V3597 () V3750) (let Result (do (shen.incinfs) (shen.th* X A V3749 V3750 (freeze (shen.th* Y (cons list (cons A ())) V3749 V3750 V3751)))) (do (shen.unbindv V3597 V3750) Result))) false)))) (if (shen.pvar? V3596) (let A (shen.newpv V3750) (do (shen.bindv V3596 (cons A ()) V3750) (let Result (do (shen.incinfs) (shen.th* X A V3749 V3750 (freeze (shen.th* Y (cons list (cons A ())) V3749 V3750 V3751)))) (do (shen.unbindv V3596 V3750) Result)))) false))) (do (shen.unbindv V3593 V3750) Result))) false))) (if (shen.pvar? V3592) (let A (shen.newpv V3750) (do (shen.bindv V3592 (cons list (cons A ())) V3750) (let Result (do (shen.incinfs) (shen.th* X A V3749 V3750 (freeze (shen.th* Y (cons list (cons A ())) V3749 V3750 V3751)))) (do (shen.unbindv V3592 V3750) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3598 (shen.lazyderef V3747 V3750) (if (cons? V3598) (let V3599 (shen.lazyderef (hd V3598) V3750) (if (= @p V3599) (let V3600 (shen.lazyderef (tl V3598) V3750) (if (cons? V3600) (let X (hd V3600) (let V3601 (shen.lazyderef (tl V3600) V3750) (if (cons? V3601) (let Y (hd V3601) (let V3602 (shen.lazyderef (tl V3601) V3750) (if (= () V3602) (let V3603 (shen.lazyderef V3748 V3750) (if (cons? V3603) (let A (hd V3603) (let V3604 (shen.lazyderef (tl V3603) V3750) (if (cons? V3604) (let V3605 (shen.lazyderef (hd V3604) V3750) (if (= * V3605) (let V3606 (shen.lazyderef (tl V3604) V3750) (if (cons? V3606) (let B (hd V3606) (let V3607 (shen.lazyderef (tl V3606) V3750) (if (= () V3607) (do (shen.incinfs) (shen.th* X A V3749 V3750 (freeze (shen.th* Y B V3749 V3750 V3751)))) (if (shen.pvar? V3607) (do (shen.bindv V3607 () V3750) (let Result (do (shen.incinfs) (shen.th* X A V3749 V3750 (freeze (shen.th* Y B V3749 V3750 V3751)))) (do (shen.unbindv V3607 V3750) Result))) false)))) (if (shen.pvar? V3606) (let B (shen.newpv V3750) (do (shen.bindv V3606 (cons B ()) V3750) (let Result (do (shen.incinfs) (shen.th* X A V3749 V3750 (freeze (shen.th* Y B V3749 V3750 V3751)))) (do (shen.unbindv V3606 V3750) Result)))) false))) (if (shen.pvar? V3605) (do (shen.bindv V3605 * V3750) (let Result (let V3608 (shen.lazyderef (tl V3604) V3750) (if (cons? V3608) (let B (hd V3608) (let V3609 (shen.lazyderef (tl V3608) V3750) (if (= () V3609) (do (shen.incinfs) (shen.th* X A V3749 V3750 (freeze (shen.th* Y B V3749 V3750 V3751)))) (if (shen.pvar? V3609) (do (shen.bindv V3609 () V3750) (let Result (do (shen.incinfs) (shen.th* X A V3749 V3750 (freeze (shen.th* Y B V3749 V3750 V3751)))) (do (shen.unbindv V3609 V3750) Result))) false)))) (if (shen.pvar? V3608) (let B (shen.newpv V3750) (do (shen.bindv V3608 (cons B ()) V3750) (let Result (do (shen.incinfs) (shen.th* X A V3749 V3750 (freeze (shen.th* Y B V3749 V3750 V3751)))) (do (shen.unbindv V3608 V3750) Result)))) false))) (do (shen.unbindv V3605 V3750) Result))) false))) (if (shen.pvar? V3604) (let B (shen.newpv V3750) (do (shen.bindv V3604 (cons * (cons B ())) V3750) (let Result (do (shen.incinfs) (shen.th* X A V3749 V3750 (freeze (shen.th* Y B V3749 V3750 V3751)))) (do (shen.unbindv V3604 V3750) Result)))) false)))) (if (shen.pvar? V3603) (let A (shen.newpv V3750) (let B (shen.newpv V3750) (do (shen.bindv V3603 (cons A (cons * (cons B ()))) V3750) (let Result (do (shen.incinfs) (shen.th* X A V3749 V3750 (freeze (shen.th* Y B V3749 V3750 V3751)))) (do (shen.unbindv V3603 V3750) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3610 (shen.lazyderef V3747 V3750) (if (cons? V3610) (let V3611 (shen.lazyderef (hd V3610) V3750) (if (= @v V3611) (let V3612 (shen.lazyderef (tl V3610) V3750) (if (cons? V3612) (let X (hd V3612) (let V3613 (shen.lazyderef (tl V3612) V3750) (if (cons? V3613) (let Y (hd V3613) (let V3614 (shen.lazyderef (tl V3613) V3750) (if (= () V3614) (let V3615 (shen.lazyderef V3748 V3750) (if (cons? V3615) (let V3616 (shen.lazyderef (hd V3615) V3750) (if (= vector V3616) (let V3617 (shen.lazyderef (tl V3615) V3750) (if (cons? V3617) (let A (hd V3617) (let V3618 (shen.lazyderef (tl V3617) V3750) (if (= () V3618) (do (shen.incinfs) (shen.th* X A V3749 V3750 (freeze (shen.th* Y (cons vector (cons A ())) V3749 V3750 V3751)))) (if (shen.pvar? V3618) (do (shen.bindv V3618 () V3750) (let Result (do (shen.incinfs) (shen.th* X A V3749 V3750 (freeze (shen.th* Y (cons vector (cons A ())) V3749 V3750 V3751)))) (do (shen.unbindv V3618 V3750) Result))) false)))) (if (shen.pvar? V3617) (let A (shen.newpv V3750) (do (shen.bindv V3617 (cons A ()) V3750) (let Result (do (shen.incinfs) (shen.th* X A V3749 V3750 (freeze (shen.th* Y (cons vector (cons A ())) V3749 V3750 V3751)))) (do (shen.unbindv V3617 V3750) Result)))) false))) (if (shen.pvar? V3616) (do (shen.bindv V3616 vector V3750) (let Result (let V3619 (shen.lazyderef (tl V3615) V3750) (if (cons? V3619) (let A (hd V3619) (let V3620 (shen.lazyderef (tl V3619) V3750) (if (= () V3620) (do (shen.incinfs) (shen.th* X A V3749 V3750 (freeze (shen.th* Y (cons vector (cons A ())) V3749 V3750 V3751)))) (if (shen.pvar? V3620) (do (shen.bindv V3620 () V3750) (let Result (do (shen.incinfs) (shen.th* X A V3749 V3750 (freeze (shen.th* Y (cons vector (cons A ())) V3749 V3750 V3751)))) (do (shen.unbindv V3620 V3750) Result))) false)))) (if (shen.pvar? V3619) (let A (shen.newpv V3750) (do (shen.bindv V3619 (cons A ()) V3750) (let Result (do (shen.incinfs) (shen.th* X A V3749 V3750 (freeze (shen.th* Y (cons vector (cons A ())) V3749 V3750 V3751)))) (do (shen.unbindv V3619 V3750) Result)))) false))) (do (shen.unbindv V3616 V3750) Result))) false))) (if (shen.pvar? V3615) (let A (shen.newpv V3750) (do (shen.bindv V3615 (cons vector (cons A ())) V3750) (let Result (do (shen.incinfs) (shen.th* X A V3749 V3750 (freeze (shen.th* Y (cons vector (cons A ())) V3749 V3750 V3751)))) (do (shen.unbindv V3615 V3750) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3621 (shen.lazyderef V3747 V3750) (if (cons? V3621) (let V3622 (shen.lazyderef (hd V3621) V3750) (if (= @s V3622) (let V3623 (shen.lazyderef (tl V3621) V3750) (if (cons? V3623) (let X (hd V3623) (let V3624 (shen.lazyderef (tl V3623) V3750) (if (cons? V3624) (let Y (hd V3624) (let V3625 (shen.lazyderef (tl V3624) V3750) (if (= () V3625) (let V3626 (shen.lazyderef V3748 V3750) (if (= string V3626) (do (shen.incinfs) (shen.th* X string V3749 V3750 (freeze (shen.th* Y string V3749 V3750 V3751)))) (if (shen.pvar? V3626) (do (shen.bindv V3626 string V3750) (let Result (do (shen.incinfs) (shen.th* X string V3749 V3750 (freeze (shen.th* Y string V3749 V3750 V3751)))) (do (shen.unbindv V3626 V3750) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3627 (shen.lazyderef V3747 V3750) (if (cons? V3627) (let V3628 (shen.lazyderef (hd V3627) V3750) (if (= lambda V3628) (let V3629 (shen.lazyderef (tl V3627) V3750) (if (cons? V3629) (let X (hd V3629) (let V3630 (shen.lazyderef (tl V3629) V3750) (if (cons? V3630) (let Y (hd V3630) (let V3631 (shen.lazyderef (tl V3630) V3750) (if (= () V3631) (let V3632 (shen.lazyderef V3748 V3750) (if (cons? V3632) (let A (hd V3632) (let V3633 (shen.lazyderef (tl V3632) V3750) (if (cons? V3633) (let V3634 (shen.lazyderef (hd V3633) V3750) (if (= --> V3634) (let V3635 (shen.lazyderef (tl V3633) V3750) (if (cons? V3635) (let B (hd V3635) (let V3636 (shen.lazyderef (tl V3635) V3750) (if (= () V3636) (let Z (shen.newpv V3750) (let X&& (shen.newpv V3750) (do (shen.incinfs) (cut Throwcontrol V3750 (freeze (bind X&& (shen.placeholder) V3750 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3750) (shen.lazyderef X V3750) (shen.lazyderef Y V3750)) V3750 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3749) V3750 V3751)))))))))) (if (shen.pvar? V3636) (do (shen.bindv V3636 () V3750) (let Result (let Z (shen.newpv V3750) (let X&& (shen.newpv V3750) (do (shen.incinfs) (cut Throwcontrol V3750 (freeze (bind X&& (shen.placeholder) V3750 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3750) (shen.lazyderef X V3750) (shen.lazyderef Y V3750)) V3750 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3749) V3750 V3751)))))))))) (do (shen.unbindv V3636 V3750) Result))) false)))) (if (shen.pvar? V3635) (let B (shen.newpv V3750) (do (shen.bindv V3635 (cons B ()) V3750) (let Result (let Z (shen.newpv V3750) (let X&& (shen.newpv V3750) (do (shen.incinfs) (cut Throwcontrol V3750 (freeze (bind X&& (shen.placeholder) V3750 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3750) (shen.lazyderef X V3750) (shen.lazyderef Y V3750)) V3750 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3749) V3750 V3751)))))))))) (do (shen.unbindv V3635 V3750) Result)))) false))) (if (shen.pvar? V3634) (do (shen.bindv V3634 --> V3750) (let Result (let V3637 (shen.lazyderef (tl V3633) V3750) (if (cons? V3637) (let B (hd V3637) (let V3638 (shen.lazyderef (tl V3637) V3750) (if (= () V3638) (let Z (shen.newpv V3750) (let X&& (shen.newpv V3750) (do (shen.incinfs) (cut Throwcontrol V3750 (freeze (bind X&& (shen.placeholder) V3750 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3750) (shen.lazyderef X V3750) (shen.lazyderef Y V3750)) V3750 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3749) V3750 V3751)))))))))) (if (shen.pvar? V3638) (do (shen.bindv V3638 () V3750) (let Result (let Z (shen.newpv V3750) (let X&& (shen.newpv V3750) (do (shen.incinfs) (cut Throwcontrol V3750 (freeze (bind X&& (shen.placeholder) V3750 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3750) (shen.lazyderef X V3750) (shen.lazyderef Y V3750)) V3750 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3749) V3750 V3751)))))))))) (do (shen.unbindv V3638 V3750) Result))) false)))) (if (shen.pvar? V3637) (let B (shen.newpv V3750) (do (shen.bindv V3637 (cons B ()) V3750) (let Result (let Z (shen.newpv V3750) (let X&& (shen.newpv V3750) (do (shen.incinfs) (cut Throwcontrol V3750 (freeze (bind X&& (shen.placeholder) V3750 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3750) (shen.lazyderef X V3750) (shen.lazyderef Y V3750)) V3750 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3749) V3750 V3751)))))))))) (do (shen.unbindv V3637 V3750) Result)))) false))) (do (shen.unbindv V3634 V3750) Result))) false))) (if (shen.pvar? V3633) (let B (shen.newpv V3750) (do (shen.bindv V3633 (cons --> (cons B ())) V3750) (let Result (let Z (shen.newpv V3750) (let X&& (shen.newpv V3750) (do (shen.incinfs) (cut Throwcontrol V3750 (freeze (bind X&& (shen.placeholder) V3750 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3750) (shen.lazyderef X V3750) (shen.lazyderef Y V3750)) V3750 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3749) V3750 V3751)))))))))) (do (shen.unbindv V3633 V3750) Result)))) false)))) (if (shen.pvar? V3632) (let A (shen.newpv V3750) (let B (shen.newpv V3750) (do (shen.bindv V3632 (cons A (cons --> (cons B ()))) V3750) (let Result (let Z (shen.newpv V3750) (let X&& (shen.newpv V3750) (do (shen.incinfs) (cut Throwcontrol V3750 (freeze (bind X&& (shen.placeholder) V3750 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3750) (shen.lazyderef X V3750) (shen.lazyderef Y V3750)) V3750 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3749) V3750 V3751)))))))))) (do (shen.unbindv V3632 V3750) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3639 (shen.lazyderef V3747 V3750) (if (cons? V3639) (let V3640 (shen.lazyderef (hd V3639) V3750) (if (= let V3640) (let V3641 (shen.lazyderef (tl V3639) V3750) (if (cons? V3641) (let X (hd V3641) (let V3642 (shen.lazyderef (tl V3641) V3750) (if (cons? V3642) (let Y (hd V3642) (let V3643 (shen.lazyderef (tl V3642) V3750) (if (cons? V3643) (let Z (hd V3643) (let V3644 (shen.lazyderef (tl V3643) V3750) (if (= () V3644) (let W (shen.newpv V3750) (let X&& (shen.newpv V3750) (let B (shen.newpv V3750) (do (shen.incinfs) (shen.th* Y B V3749 V3750 (freeze (bind X&& (shen.placeholder) V3750 (freeze (bind W (shen.ebr (shen.lazyderef X&& V3750) (shen.lazyderef X V3750) (shen.lazyderef Z V3750)) V3750 (freeze (shen.th* W V3748 (cons (cons X&& (cons : (cons B ()))) V3749) V3750 V3751))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3645 (shen.lazyderef V3747 V3750) (if (cons? V3645) (let V3646 (shen.lazyderef (hd V3645) V3750) (if (= open V3646) (let V3647 (shen.lazyderef (tl V3645) V3750) (if (cons? V3647) (let FileName (hd V3647) (let V3648 (shen.lazyderef (tl V3647) V3750) (if (cons? V3648) (let Direction3578 (hd V3648) (let V3649 (shen.lazyderef (tl V3648) V3750) (if (= () V3649) (let V3650 (shen.lazyderef V3748 V3750) (if (cons? V3650) (let V3651 (shen.lazyderef (hd V3650) V3750) (if (= stream V3651) (let V3652 (shen.lazyderef (tl V3650) V3750) (if (cons? V3652) (let Direction (hd V3652) (let V3653 (shen.lazyderef (tl V3652) V3750) (if (= () V3653) (do (shen.incinfs) (unify! Direction Direction3578 V3750 (freeze (cut Throwcontrol V3750 (freeze (fwhen (element? (shen.lazyderef Direction V3750) (cons in (cons out ()))) V3750 (freeze (shen.th* FileName string V3749 V3750 V3751)))))))) (if (shen.pvar? V3653) (do (shen.bindv V3653 () V3750) (let Result (do (shen.incinfs) (unify! Direction Direction3578 V3750 (freeze (cut Throwcontrol V3750 (freeze (fwhen (element? (shen.lazyderef Direction V3750) (cons in (cons out ()))) V3750 (freeze (shen.th* FileName string V3749 V3750 V3751)))))))) (do (shen.unbindv V3653 V3750) Result))) false)))) (if (shen.pvar? V3652) (let Direction (shen.newpv V3750) (do (shen.bindv V3652 (cons Direction ()) V3750) (let Result (do (shen.incinfs) (unify! Direction Direction3578 V3750 (freeze (cut Throwcontrol V3750 (freeze (fwhen (element? (shen.lazyderef Direction V3750) (cons in (cons out ()))) V3750 (freeze (shen.th* FileName string V3749 V3750 V3751)))))))) (do (shen.unbindv V3652 V3750) Result)))) false))) (if (shen.pvar? V3651) (do (shen.bindv V3651 stream V3750) (let Result (let V3654 (shen.lazyderef (tl V3650) V3750) (if (cons? V3654) (let Direction (hd V3654) (let V3655 (shen.lazyderef (tl V3654) V3750) (if (= () V3655) (do (shen.incinfs) (unify! Direction Direction3578 V3750 (freeze (cut Throwcontrol V3750 (freeze (fwhen (element? (shen.lazyderef Direction V3750) (cons in (cons out ()))) V3750 (freeze (shen.th* FileName string V3749 V3750 V3751)))))))) (if (shen.pvar? V3655) (do (shen.bindv V3655 () V3750) (let Result (do (shen.incinfs) (unify! Direction Direction3578 V3750 (freeze (cut Throwcontrol V3750 (freeze (fwhen (element? (shen.lazyderef Direction V3750) (cons in (cons out ()))) V3750 (freeze (shen.th* FileName string V3749 V3750 V3751)))))))) (do (shen.unbindv V3655 V3750) Result))) false)))) (if (shen.pvar? V3654) (let Direction (shen.newpv V3750) (do (shen.bindv V3654 (cons Direction ()) V3750) (let Result (do (shen.incinfs) (unify! Direction Direction3578 V3750 (freeze (cut Throwcontrol V3750 (freeze (fwhen (element? (shen.lazyderef Direction V3750) (cons in (cons out ()))) V3750 (freeze (shen.th* FileName string V3749 V3750 V3751)))))))) (do (shen.unbindv V3654 V3750) Result)))) false))) (do (shen.unbindv V3651 V3750) Result))) false))) (if (shen.pvar? V3650) (let Direction (shen.newpv V3750) (do (shen.bindv V3650 (cons stream (cons Direction ())) V3750) (let Result (do (shen.incinfs) (unify! Direction Direction3578 V3750 (freeze (cut Throwcontrol V3750 (freeze (fwhen (element? (shen.lazyderef Direction V3750) (cons in (cons out ()))) V3750 (freeze (shen.th* FileName string V3749 V3750 V3751)))))))) (do (shen.unbindv V3650 V3750) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3656 (shen.lazyderef V3747 V3750) (if (cons? V3656) (let V3657 (shen.lazyderef (hd V3656) V3750) (if (= type V3657) (let V3658 (shen.lazyderef (tl V3656) V3750) (if (cons? V3658) (let X (hd V3658) (let V3659 (shen.lazyderef (tl V3658) V3750) (if (cons? V3659) (let A (hd V3659) (let V3660 (shen.lazyderef (tl V3659) V3750) (if (= () V3660) (do (shen.incinfs) (cut Throwcontrol V3750 (freeze (unify A V3748 V3750 (freeze (shen.th* X A V3749 V3750 V3751)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3661 (shen.lazyderef V3747 V3750) (if (cons? V3661) (let V3662 (shen.lazyderef (hd V3661) V3750) (if (= input+ V3662) (let V3663 (shen.lazyderef (tl V3661) V3750) (if (cons? V3663) (let A (hd V3663) (let V3664 (shen.lazyderef (tl V3663) V3750) (if (cons? V3664) (let Stream (hd V3664) (let V3665 (shen.lazyderef (tl V3664) V3750) (if (= () V3665) (let C (shen.newpv V3750) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V3750)) V3750 (freeze (unify V3748 C V3750 (freeze (shen.th* Stream (cons stream (cons in ())) V3749 V3750 V3751))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3666 (shen.lazyderef V3747 V3750) (if (cons? V3666) (let V3667 (shen.lazyderef (hd V3666) V3750) (if (= set V3667) (let V3668 (shen.lazyderef (tl V3666) V3750) (if (cons? V3668) (let Var (hd V3668) (let V3669 (shen.lazyderef (tl V3668) V3750) (if (cons? V3669) (let Val (hd V3669) (let V3670 (shen.lazyderef (tl V3669) V3750) (if (= () V3670) (do (shen.incinfs) (cut Throwcontrol V3750 (freeze (shen.th* Var symbol V3749 V3750 (freeze (cut Throwcontrol V3750 (freeze (shen.th* (cons value (cons Var ())) V3748 V3749 V3750 (freeze (shen.th* Val V3748 V3749 V3750 V3751)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V3750) (do (shen.incinfs) (shen.t*-hyps V3749 NewHyp V3750 (freeze (shen.th* V3747 V3748 NewHyp V3750 V3751))))) (if (= Case false) (let Case (let V3671 (shen.lazyderef V3747 V3750) (if (cons? V3671) (let V3672 (shen.lazyderef (hd V3671) V3750) (if (= define V3672) (let V3673 (shen.lazyderef (tl V3671) V3750) (if (cons? V3673) (let F (hd V3673) (let X (tl V3673) (do (shen.incinfs) (cut Throwcontrol V3750 (freeze (shen.t*-def (cons define (cons F X)) V3748 V3749 V3750 V3751)))))) false)) false)) false)) (if (= Case false) (let Case (let V3674 (shen.lazyderef V3747 V3750) (if (cons? V3674) (let V3675 (shen.lazyderef (hd V3674) V3750) (if (= defmacro V3675) (let V3676 (shen.lazyderef V3748 V3750) (if (= unit V3676) (do (shen.incinfs) (cut Throwcontrol V3750 V3751)) (if (shen.pvar? V3676) (do (shen.bindv V3676 unit V3750) (let Result (do (shen.incinfs) (cut Throwcontrol V3750 V3751)) (do (shen.unbindv V3676 V3750) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3677 (shen.lazyderef V3747 V3750) (if (cons? V3677) (let V3678 (shen.lazyderef (hd V3677) V3750) (if (= shen.process-datatype V3678) (let V3679 (shen.lazyderef V3748 V3750) (if (= symbol V3679) (do (shen.incinfs) (thaw V3751)) (if (shen.pvar? V3679) (do (shen.bindv V3679 symbol V3750) (let Result (do (shen.incinfs) (thaw V3751)) (do (shen.unbindv V3679 V3750) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3680 (shen.lazyderef V3747 V3750) (if (cons? V3680) (let V3681 (shen.lazyderef (hd V3680) V3750) (if (= shen.synonyms-help V3681) (let V3682 (shen.lazyderef V3748 V3750) (if (= symbol V3682) (do (shen.incinfs) (thaw V3751)) (if (shen.pvar? V3682) (do (shen.bindv V3682 symbol V3750) (let Result (do (shen.incinfs) (thaw V3751)) (do (shen.unbindv V3682 V3750) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V3750) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V3750 (freeze (shen.udefs* (cons V3747 (cons : (cons V3748 ()))) V3749 Datatypes V3750 V3751))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V3756 V3757 V3758 V3759) (let Case (let V3493 (shen.lazyderef V3756 V3758) (if (cons? V3493) (let V3494 (shen.lazyderef (hd V3493) V3758) (if (cons? V3494) (let V3495 (shen.lazyderef (hd V3494) V3758) (if (cons? V3495) (let V3496 (shen.lazyderef (hd V3495) V3758) (if (= cons V3496) (let V3497 (shen.lazyderef (tl V3495) V3758) (if (cons? V3497) (let X (hd V3497) (let V3498 (shen.lazyderef (tl V3497) V3758) (if (cons? V3498) (let Y (hd V3498) (let V3499 (shen.lazyderef (tl V3498) V3758) (if (= () V3499) (let V3500 (shen.lazyderef (tl V3494) V3758) (if (cons? V3500) (let V3501 (shen.lazyderef (hd V3500) V3758) (if (= : V3501) (let V3502 (shen.lazyderef (tl V3500) V3758) (if (cons? V3502) (let V3503 (shen.lazyderef (hd V3502) V3758) (if (cons? V3503) (let V3504 (shen.lazyderef (hd V3503) V3758) (if (= list V3504) (let V3505 (shen.lazyderef (tl V3503) V3758) (if (cons? V3505) (let A (hd V3505) (let V3506 (shen.lazyderef (tl V3505) V3758) (if (= () V3506) (let V3507 (shen.lazyderef (tl V3502) V3758) (if (= () V3507) (let Hyp (tl V3493) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons list (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (if (shen.pvar? V3507) (do (shen.bindv V3507 () V3758) (let Result (let Hyp (tl V3493) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons list (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (do (shen.unbindv V3507 V3758) Result))) false))) (if (shen.pvar? V3506) (do (shen.bindv V3506 () V3758) (let Result (let V3508 (shen.lazyderef (tl V3502) V3758) (if (= () V3508) (let Hyp (tl V3493) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons list (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (if (shen.pvar? V3508) (do (shen.bindv V3508 () V3758) (let Result (let Hyp (tl V3493) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons list (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (do (shen.unbindv V3508 V3758) Result))) false))) (do (shen.unbindv V3506 V3758) Result))) false)))) (if (shen.pvar? V3505) (let A (shen.newpv V3758) (do (shen.bindv V3505 (cons A ()) V3758) (let Result (let V3509 (shen.lazyderef (tl V3502) V3758) (if (= () V3509) (let Hyp (tl V3493) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons list (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (if (shen.pvar? V3509) (do (shen.bindv V3509 () V3758) (let Result (let Hyp (tl V3493) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons list (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (do (shen.unbindv V3509 V3758) Result))) false))) (do (shen.unbindv V3505 V3758) Result)))) false))) (if (shen.pvar? V3504) (do (shen.bindv V3504 list V3758) (let Result (let V3510 (shen.lazyderef (tl V3503) V3758) (if (cons? V3510) (let A (hd V3510) (let V3511 (shen.lazyderef (tl V3510) V3758) (if (= () V3511) (let V3512 (shen.lazyderef (tl V3502) V3758) (if (= () V3512) (let Hyp (tl V3493) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons list (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (if (shen.pvar? V3512) (do (shen.bindv V3512 () V3758) (let Result (let Hyp (tl V3493) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons list (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (do (shen.unbindv V3512 V3758) Result))) false))) (if (shen.pvar? V3511) (do (shen.bindv V3511 () V3758) (let Result (let V3513 (shen.lazyderef (tl V3502) V3758) (if (= () V3513) (let Hyp (tl V3493) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons list (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (if (shen.pvar? V3513) (do (shen.bindv V3513 () V3758) (let Result (let Hyp (tl V3493) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons list (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (do (shen.unbindv V3513 V3758) Result))) false))) (do (shen.unbindv V3511 V3758) Result))) false)))) (if (shen.pvar? V3510) (let A (shen.newpv V3758) (do (shen.bindv V3510 (cons A ()) V3758) (let Result (let V3514 (shen.lazyderef (tl V3502) V3758) (if (= () V3514) (let Hyp (tl V3493) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons list (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (if (shen.pvar? V3514) (do (shen.bindv V3514 () V3758) (let Result (let Hyp (tl V3493) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons list (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (do (shen.unbindv V3514 V3758) Result))) false))) (do (shen.unbindv V3510 V3758) Result)))) false))) (do (shen.unbindv V3504 V3758) Result))) false))) (if (shen.pvar? V3503) (let A (shen.newpv V3758) (do (shen.bindv V3503 (cons list (cons A ())) V3758) (let Result (let V3515 (shen.lazyderef (tl V3502) V3758) (if (= () V3515) (let Hyp (tl V3493) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons list (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (if (shen.pvar? V3515) (do (shen.bindv V3515 () V3758) (let Result (let Hyp (tl V3493) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons list (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (do (shen.unbindv V3515 V3758) Result))) false))) (do (shen.unbindv V3503 V3758) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3516 (shen.lazyderef V3756 V3758) (if (cons? V3516) (let V3517 (shen.lazyderef (hd V3516) V3758) (if (cons? V3517) (let V3518 (shen.lazyderef (hd V3517) V3758) (if (cons? V3518) (let V3519 (shen.lazyderef (hd V3518) V3758) (if (= @p V3519) (let V3520 (shen.lazyderef (tl V3518) V3758) (if (cons? V3520) (let X (hd V3520) (let V3521 (shen.lazyderef (tl V3520) V3758) (if (cons? V3521) (let Y (hd V3521) (let V3522 (shen.lazyderef (tl V3521) V3758) (if (= () V3522) (let V3523 (shen.lazyderef (tl V3517) V3758) (if (cons? V3523) (let V3524 (shen.lazyderef (hd V3523) V3758) (if (= : V3524) (let V3525 (shen.lazyderef (tl V3523) V3758) (if (cons? V3525) (let V3526 (shen.lazyderef (hd V3525) V3758) (if (cons? V3526) (let A (hd V3526) (let V3527 (shen.lazyderef (tl V3526) V3758) (if (cons? V3527) (let V3528 (shen.lazyderef (hd V3527) V3758) (if (= * V3528) (let V3529 (shen.lazyderef (tl V3527) V3758) (if (cons? V3529) (let B (hd V3529) (let V3530 (shen.lazyderef (tl V3529) V3758) (if (= () V3530) (let V3531 (shen.lazyderef (tl V3525) V3758) (if (= () V3531) (let Hyp (tl V3516) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (shen.lazyderef B V3758) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (if (shen.pvar? V3531) (do (shen.bindv V3531 () V3758) (let Result (let Hyp (tl V3516) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (shen.lazyderef B V3758) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (do (shen.unbindv V3531 V3758) Result))) false))) (if (shen.pvar? V3530) (do (shen.bindv V3530 () V3758) (let Result (let V3532 (shen.lazyderef (tl V3525) V3758) (if (= () V3532) (let Hyp (tl V3516) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (shen.lazyderef B V3758) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (if (shen.pvar? V3532) (do (shen.bindv V3532 () V3758) (let Result (let Hyp (tl V3516) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (shen.lazyderef B V3758) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (do (shen.unbindv V3532 V3758) Result))) false))) (do (shen.unbindv V3530 V3758) Result))) false)))) (if (shen.pvar? V3529) (let B (shen.newpv V3758) (do (shen.bindv V3529 (cons B ()) V3758) (let Result (let V3533 (shen.lazyderef (tl V3525) V3758) (if (= () V3533) (let Hyp (tl V3516) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (shen.lazyderef B V3758) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (if (shen.pvar? V3533) (do (shen.bindv V3533 () V3758) (let Result (let Hyp (tl V3516) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (shen.lazyderef B V3758) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (do (shen.unbindv V3533 V3758) Result))) false))) (do (shen.unbindv V3529 V3758) Result)))) false))) (if (shen.pvar? V3528) (do (shen.bindv V3528 * V3758) (let Result (let V3534 (shen.lazyderef (tl V3527) V3758) (if (cons? V3534) (let B (hd V3534) (let V3535 (shen.lazyderef (tl V3534) V3758) (if (= () V3535) (let V3536 (shen.lazyderef (tl V3525) V3758) (if (= () V3536) (let Hyp (tl V3516) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (shen.lazyderef B V3758) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (if (shen.pvar? V3536) (do (shen.bindv V3536 () V3758) (let Result (let Hyp (tl V3516) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (shen.lazyderef B V3758) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (do (shen.unbindv V3536 V3758) Result))) false))) (if (shen.pvar? V3535) (do (shen.bindv V3535 () V3758) (let Result (let V3537 (shen.lazyderef (tl V3525) V3758) (if (= () V3537) (let Hyp (tl V3516) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (shen.lazyderef B V3758) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (if (shen.pvar? V3537) (do (shen.bindv V3537 () V3758) (let Result (let Hyp (tl V3516) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (shen.lazyderef B V3758) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (do (shen.unbindv V3537 V3758) Result))) false))) (do (shen.unbindv V3535 V3758) Result))) false)))) (if (shen.pvar? V3534) (let B (shen.newpv V3758) (do (shen.bindv V3534 (cons B ()) V3758) (let Result (let V3538 (shen.lazyderef (tl V3525) V3758) (if (= () V3538) (let Hyp (tl V3516) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (shen.lazyderef B V3758) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (if (shen.pvar? V3538) (do (shen.bindv V3538 () V3758) (let Result (let Hyp (tl V3516) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (shen.lazyderef B V3758) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (do (shen.unbindv V3538 V3758) Result))) false))) (do (shen.unbindv V3534 V3758) Result)))) false))) (do (shen.unbindv V3528 V3758) Result))) false))) (if (shen.pvar? V3527) (let B (shen.newpv V3758) (do (shen.bindv V3527 (cons * (cons B ())) V3758) (let Result (let V3539 (shen.lazyderef (tl V3525) V3758) (if (= () V3539) (let Hyp (tl V3516) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (shen.lazyderef B V3758) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (if (shen.pvar? V3539) (do (shen.bindv V3539 () V3758) (let Result (let Hyp (tl V3516) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (shen.lazyderef B V3758) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (do (shen.unbindv V3539 V3758) Result))) false))) (do (shen.unbindv V3527 V3758) Result)))) false)))) (if (shen.pvar? V3526) (let A (shen.newpv V3758) (let B (shen.newpv V3758) (do (shen.bindv V3526 (cons A (cons * (cons B ()))) V3758) (let Result (let V3540 (shen.lazyderef (tl V3525) V3758) (if (= () V3540) (let Hyp (tl V3516) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (shen.lazyderef B V3758) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (if (shen.pvar? V3540) (do (shen.bindv V3540 () V3758) (let Result (let Hyp (tl V3516) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (shen.lazyderef B V3758) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (do (shen.unbindv V3540 V3758) Result))) false))) (do (shen.unbindv V3526 V3758) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3541 (shen.lazyderef V3756 V3758) (if (cons? V3541) (let V3542 (shen.lazyderef (hd V3541) V3758) (if (cons? V3542) (let V3543 (shen.lazyderef (hd V3542) V3758) (if (cons? V3543) (let V3544 (shen.lazyderef (hd V3543) V3758) (if (= @v V3544) (let V3545 (shen.lazyderef (tl V3543) V3758) (if (cons? V3545) (let X (hd V3545) (let V3546 (shen.lazyderef (tl V3545) V3758) (if (cons? V3546) (let Y (hd V3546) (let V3547 (shen.lazyderef (tl V3546) V3758) (if (= () V3547) (let V3548 (shen.lazyderef (tl V3542) V3758) (if (cons? V3548) (let V3549 (shen.lazyderef (hd V3548) V3758) (if (= : V3549) (let V3550 (shen.lazyderef (tl V3548) V3758) (if (cons? V3550) (let V3551 (shen.lazyderef (hd V3550) V3758) (if (cons? V3551) (let V3552 (shen.lazyderef (hd V3551) V3758) (if (= vector V3552) (let V3553 (shen.lazyderef (tl V3551) V3758) (if (cons? V3553) (let A (hd V3553) (let V3554 (shen.lazyderef (tl V3553) V3758) (if (= () V3554) (let V3555 (shen.lazyderef (tl V3550) V3758) (if (= () V3555) (let Hyp (tl V3541) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons vector (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (if (shen.pvar? V3555) (do (shen.bindv V3555 () V3758) (let Result (let Hyp (tl V3541) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons vector (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (do (shen.unbindv V3555 V3758) Result))) false))) (if (shen.pvar? V3554) (do (shen.bindv V3554 () V3758) (let Result (let V3556 (shen.lazyderef (tl V3550) V3758) (if (= () V3556) (let Hyp (tl V3541) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons vector (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (if (shen.pvar? V3556) (do (shen.bindv V3556 () V3758) (let Result (let Hyp (tl V3541) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons vector (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (do (shen.unbindv V3556 V3758) Result))) false))) (do (shen.unbindv V3554 V3758) Result))) false)))) (if (shen.pvar? V3553) (let A (shen.newpv V3758) (do (shen.bindv V3553 (cons A ()) V3758) (let Result (let V3557 (shen.lazyderef (tl V3550) V3758) (if (= () V3557) (let Hyp (tl V3541) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons vector (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (if (shen.pvar? V3557) (do (shen.bindv V3557 () V3758) (let Result (let Hyp (tl V3541) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons vector (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (do (shen.unbindv V3557 V3758) Result))) false))) (do (shen.unbindv V3553 V3758) Result)))) false))) (if (shen.pvar? V3552) (do (shen.bindv V3552 vector V3758) (let Result (let V3558 (shen.lazyderef (tl V3551) V3758) (if (cons? V3558) (let A (hd V3558) (let V3559 (shen.lazyderef (tl V3558) V3758) (if (= () V3559) (let V3560 (shen.lazyderef (tl V3550) V3758) (if (= () V3560) (let Hyp (tl V3541) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons vector (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (if (shen.pvar? V3560) (do (shen.bindv V3560 () V3758) (let Result (let Hyp (tl V3541) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons vector (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (do (shen.unbindv V3560 V3758) Result))) false))) (if (shen.pvar? V3559) (do (shen.bindv V3559 () V3758) (let Result (let V3561 (shen.lazyderef (tl V3550) V3758) (if (= () V3561) (let Hyp (tl V3541) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons vector (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (if (shen.pvar? V3561) (do (shen.bindv V3561 () V3758) (let Result (let Hyp (tl V3541) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons vector (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (do (shen.unbindv V3561 V3758) Result))) false))) (do (shen.unbindv V3559 V3758) Result))) false)))) (if (shen.pvar? V3558) (let A (shen.newpv V3758) (do (shen.bindv V3558 (cons A ()) V3758) (let Result (let V3562 (shen.lazyderef (tl V3550) V3758) (if (= () V3562) (let Hyp (tl V3541) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons vector (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (if (shen.pvar? V3562) (do (shen.bindv V3562 () V3758) (let Result (let Hyp (tl V3541) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons vector (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (do (shen.unbindv V3562 V3758) Result))) false))) (do (shen.unbindv V3558 V3758) Result)))) false))) (do (shen.unbindv V3552 V3758) Result))) false))) (if (shen.pvar? V3551) (let A (shen.newpv V3758) (do (shen.bindv V3551 (cons vector (cons A ())) V3758) (let Result (let V3563 (shen.lazyderef (tl V3550) V3758) (if (= () V3563) (let Hyp (tl V3541) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons vector (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (if (shen.pvar? V3563) (do (shen.bindv V3563 () V3758) (let Result (let Hyp (tl V3541) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons (shen.lazyderef A V3758) ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons (cons vector (cons (shen.lazyderef A V3758) ())) ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (do (shen.unbindv V3563 V3758) Result))) false))) (do (shen.unbindv V3551 V3758) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3564 (shen.lazyderef V3756 V3758) (if (cons? V3564) (let V3565 (shen.lazyderef (hd V3564) V3758) (if (cons? V3565) (let V3566 (shen.lazyderef (hd V3565) V3758) (if (cons? V3566) (let V3567 (shen.lazyderef (hd V3566) V3758) (if (= @s V3567) (let V3568 (shen.lazyderef (tl V3566) V3758) (if (cons? V3568) (let X (hd V3568) (let V3569 (shen.lazyderef (tl V3568) V3758) (if (cons? V3569) (let Y (hd V3569) (let V3570 (shen.lazyderef (tl V3569) V3758) (if (= () V3570) (let V3571 (shen.lazyderef (tl V3565) V3758) (if (cons? V3571) (let V3572 (shen.lazyderef (hd V3571) V3758) (if (= : V3572) (let V3573 (shen.lazyderef (tl V3571) V3758) (if (cons? V3573) (let V3574 (shen.lazyderef (hd V3573) V3758) (if (= string V3574) (let V3575 (shen.lazyderef (tl V3573) V3758) (if (= () V3575) (let Hyp (tl V3564) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons string ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (if (shen.pvar? V3575) (do (shen.bindv V3575 () V3758) (let Result (let Hyp (tl V3564) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons string ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (do (shen.unbindv V3575 V3758) Result))) false))) (if (shen.pvar? V3574) (do (shen.bindv V3574 string V3758) (let Result (let V3576 (shen.lazyderef (tl V3573) V3758) (if (= () V3576) (let Hyp (tl V3564) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons string ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (if (shen.pvar? V3576) (do (shen.bindv V3576 () V3758) (let Result (let Hyp (tl V3564) (do (shen.incinfs) (bind V3757 (cons (cons (shen.lazyderef X V3758) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3758) (cons : (cons string ()))) (shen.lazyderef Hyp V3758))) V3758 V3759))) (do (shen.unbindv V3576 V3758) Result))) false))) (do (shen.unbindv V3574 V3758) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V3577 (shen.lazyderef V3756 V3758) (if (cons? V3577) (let X (hd V3577) (let Hyp (tl V3577) (let NewHyps (shen.newpv V3758) (do (shen.incinfs) (bind V3757 (cons (shen.lazyderef X V3758) (shen.lazyderef NewHyps V3758)) V3758 (freeze (shen.t*-hyps Hyp NewHyps V3758 V3759))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V3776 V3777 V3778 V3779) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V3776 V3778)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V3777 V3778) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V3779))))))))) (true (thaw V3779))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V3781) (cond ((and (cons? V3781) (and (cons? (tl V3781)) (and (= : (hd (tl V3781))) (and (cons? (tl (tl V3781))) (= () (tl (tl (tl V3781)))))))) (shen.prhush (shen.app (hd V3781) (cn " : " (shen.app (hd (tl (tl V3781))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V3781 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V3786 V3787) (cond ((= () V3786) shen.skip) ((cons? V3786) (do (shen.prhush (shen.app V3787 ". " shen.a) (stoutput)) (do (shen.show-p (hd V3786)) (do (nl 1) (shen.show-assumptions (tl V3786) (+ V3787 1)))))) (true (shen.f_error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V3789) (cons? (assoc V3789 (value shen.*signedfuncs*))))

(defun shen.sigf (V3791) (concat shen.type-signature-of- V3791))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V3796 V3797 V3798 V3799) (let Case (let V3480 (shen.lazyderef V3797 V3798) (if (= number V3480) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3796 V3798)) V3798 V3799)) (if (shen.pvar? V3480) (do (shen.bindv V3480 number V3798) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3796 V3798)) V3798 V3799)) (do (shen.unbindv V3480 V3798) Result))) false))) (if (= Case false) (let Case (let V3481 (shen.lazyderef V3797 V3798) (if (= boolean V3481) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3796 V3798)) V3798 V3799)) (if (shen.pvar? V3481) (do (shen.bindv V3481 boolean V3798) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3796 V3798)) V3798 V3799)) (do (shen.unbindv V3481 V3798) Result))) false))) (if (= Case false) (let Case (let V3482 (shen.lazyderef V3797 V3798) (if (= string V3482) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3796 V3798)) V3798 V3799)) (if (shen.pvar? V3482) (do (shen.bindv V3482 string V3798) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3796 V3798)) V3798 V3799)) (do (shen.unbindv V3482 V3798) Result))) false))) (if (= Case false) (let Case (let V3483 (shen.lazyderef V3797 V3798) (if (= symbol V3483) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3796 V3798)) V3798 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3796 V3798))) V3798 V3799)))) (if (shen.pvar? V3483) (do (shen.bindv V3483 symbol V3798) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3796 V3798)) V3798 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3796 V3798))) V3798 V3799)))) (do (shen.unbindv V3483 V3798) Result))) false))) (if (= Case false) (let V3484 (shen.lazyderef V3796 V3798) (if (= () V3484) (let V3485 (shen.lazyderef V3797 V3798) (if (cons? V3485) (let V3486 (shen.lazyderef (hd V3485) V3798) (if (= list V3486) (let V3487 (shen.lazyderef (tl V3485) V3798) (if (cons? V3487) (let A (hd V3487) (let V3488 (shen.lazyderef (tl V3487) V3798) (if (= () V3488) (do (shen.incinfs) (thaw V3799)) (if (shen.pvar? V3488) (do (shen.bindv V3488 () V3798) (let Result (do (shen.incinfs) (thaw V3799)) (do (shen.unbindv V3488 V3798) Result))) false)))) (if (shen.pvar? V3487) (let A (shen.newpv V3798) (do (shen.bindv V3487 (cons A ()) V3798) (let Result (do (shen.incinfs) (thaw V3799)) (do (shen.unbindv V3487 V3798) Result)))) false))) (if (shen.pvar? V3486) (do (shen.bindv V3486 list V3798) (let Result (let V3489 (shen.lazyderef (tl V3485) V3798) (if (cons? V3489) (let A (hd V3489) (let V3490 (shen.lazyderef (tl V3489) V3798) (if (= () V3490) (do (shen.incinfs) (thaw V3799)) (if (shen.pvar? V3490) (do (shen.bindv V3490 () V3798) (let Result (do (shen.incinfs) (thaw V3799)) (do (shen.unbindv V3490 V3798) Result))) false)))) (if (shen.pvar? V3489) (let A (shen.newpv V3798) (do (shen.bindv V3489 (cons A ()) V3798) (let Result (do (shen.incinfs) (thaw V3799)) (do (shen.unbindv V3489 V3798) Result)))) false))) (do (shen.unbindv V3486 V3798) Result))) false))) (if (shen.pvar? V3485) (let A (shen.newpv V3798) (do (shen.bindv V3485 (cons list (cons A ())) V3798) (let Result (do (shen.incinfs) (thaw V3799)) (do (shen.unbindv V3485 V3798) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V3805 V3806 V3807 V3808 V3809) (let Case (let V3471 (shen.lazyderef V3807 V3808) (if (cons? V3471) (let V3472 (shen.lazyderef (hd V3471) V3808) (if (cons? V3472) (let Y (hd V3472) (let V3473 (shen.lazyderef (tl V3472) V3808) (if (cons? V3473) (let V3474 (shen.lazyderef (hd V3473) V3808) (if (= : V3474) (let V3475 (shen.lazyderef (tl V3473) V3808) (if (cons? V3475) (let B (hd V3475) (let V3476 (shen.lazyderef (tl V3475) V3808) (if (= () V3476) (do (shen.incinfs) (identical V3805 Y V3808 (freeze (unify! V3806 B V3808 V3809)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V3477 (shen.lazyderef V3807 V3808) (if (cons? V3477) (let Hyp (tl V3477) (do (shen.incinfs) (shen.by_hypothesis V3805 V3806 Hyp V3808 V3809))) false)) Case)))

(defun shen.t*-def (V3815 V3816 V3817 V3818 V3819) (let V3465 (shen.lazyderef V3815 V3818) (if (cons? V3465) (let V3466 (shen.lazyderef (hd V3465) V3818) (if (= define V3466) (let V3467 (shen.lazyderef (tl V3465) V3818) (if (cons? V3467) (let F (hd V3467) (let X (tl V3467) (let Y (shen.newpv V3818) (let E (shen.newpv V3818) (do (shen.incinfs) (shen.t*-defh (compile (lambda Y (shen.<sig+rules> Y)) X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V3816 V3817 V3818 V3819)))))) false)) false)) false)))

(defun shen.t*-defh (V3826 V3827 V3828 V3829 V3830 V3831) (let V3461 (shen.lazyderef V3826 V3830) (if (cons? V3461) (let Sig (hd V3461) (let Rules (tl V3461) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V3827 V3828 V3829 Rules V3830 V3831)))) false)))

(defun shen.t*-defhh (V3840 V3841 V3842 V3843 V3844 V3845 V3846 V3847) (do (shen.incinfs) (shen.t*-rules V3845 V3841 1 V3842 (cons (cons V3842 (cons : (cons V3841 ()))) V3844) V3846 (freeze (shen.memo V3842 V3840 V3843 V3846 V3847)))))

(defun shen.memo (V3853 V3854 V3855 V3856 V3857) (let Jnk (shen.newpv V3856) (do (shen.incinfs) (unify! V3855 V3854 V3856 (freeze (bind Jnk (declare (shen.lazyderef V3853 V3856) (shen.lazyderef V3855 V3856)) V3856 V3857))))))

(defun shen.<sig+rules> (V3859) (let Parse_shen.<signature> (shen.<signature> V3859) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))))

(defun shen.<non-ll-rules> (V3861) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V3861) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<rule>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V3861) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.hdtl Parse_shen.<rule>) ())) (fail))) YaccParse)))

(defun shen.ue (V3863) (cond ((and (cons? V3863) (and (cons? (tl V3863)) (and (= () (tl (tl V3863))) (= (hd V3863) protect)))) V3863) ((cons? V3863) (map (lambda Z (shen.ue Z)) V3863)) ((variable? V3863) (concat && V3863)) (true V3863)))

(defun shen.ue-sig (V3865) (cond ((cons? V3865) (map (lambda Z (shen.ue-sig Z)) V3865)) ((variable? V3865) (concat &&& V3865)) (true V3865)))

(defun shen.ues (V3871) (cond ((shen.ue? V3871) (cons V3871 ())) ((cons? V3871) (union (shen.ues (hd V3871)) (shen.ues (tl V3871)))) (true ())))

(defun shen.ue? (V3873) (and (symbol? V3873) (shen.ue-h? (str V3873))))

(defun shen.ue-h? (V3881) (cond ((and (shen.+string? V3881) (and (= "&" (pos V3881 0)) (and (shen.+string? (tlstr V3881)) (= "&" (pos (tlstr V3881) 0))))) true) (true false)))

(defun shen.t*-rules (V3889 V3890 V3891 V3892 V3893 V3894 V3895) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3445 (shen.lazyderef V3889 V3894) (if (= () V3445) (do (shen.incinfs) (thaw V3895)) false)) (if (= Case false) (let Case (let V3446 (shen.lazyderef V3889 V3894) (if (cons? V3446) (let Rule (hd V3446) (let Rules (tl V3446) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V3890 V3893 V3894 (freeze (cut Throwcontrol V3894 (freeze (shen.t*-rules Rules V3890 (+ V3891 1) V3892 V3893 V3894 V3895)))))))) false)) (if (= Case false) (let Err (shen.newpv V3894) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V3891 V3894) (cn " of " (shen.app (shen.lazyderef V3892 V3894) "" shen.a)) shen.a))) V3894 V3895))) Case)) Case)))))

(defun shen.t*-rule (V3901 V3902 V3903 V3904 V3905) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V3437 (shen.lazyderef V3901 V3904) (if (cons? V3437) (let Patterns (hd V3437) (let V3438 (shen.lazyderef (tl V3437) V3904) (if (cons? V3438) (let Action (hd V3438) (let V3439 (shen.lazyderef (tl V3438) V3904) (if (= () V3439) (let NewHyps (shen.newpv V3904) (do (shen.incinfs) (shen.newhyps (shen.placeholders Patterns) V3903 NewHyps V3904 (freeze (shen.t*-patterns Patterns V3902 NewHyps V3904 (freeze (cut Throwcontrol V3904 (freeze (shen.t*-action (shen.curry (shen.ue Action)) (shen.result-type Patterns V3902) (shen.patthyps Patterns V3902 V3903) V3904 V3905))))))))) false))) false))) false)))))

(defun shen.placeholders (V3911) (cond ((shen.ue? V3911) (cons V3911 ())) ((cons? V3911) (union (shen.placeholders (hd V3911)) (shen.placeholders (tl V3911)))) (true ())))

(defun shen.newhyps (V3917 V3918 V3919 V3920 V3921) (let Case (let V3424 (shen.lazyderef V3917 V3920) (if (= () V3424) (do (shen.incinfs) (unify! V3919 V3918 V3920 V3921)) false)) (if (= Case false) (let V3425 (shen.lazyderef V3917 V3920) (if (cons? V3425) (let V3420 (hd V3425) (let Vs (tl V3425) (let V3426 (shen.lazyderef V3919 V3920) (if (cons? V3426) (let V3427 (shen.lazyderef (hd V3426) V3920) (if (cons? V3427) (let V (hd V3427) (let V3428 (shen.lazyderef (tl V3427) V3920) (if (cons? V3428) (let V3429 (shen.lazyderef (hd V3428) V3920) (if (= : V3429) (let V3430 (shen.lazyderef (tl V3428) V3920) (if (cons? V3430) (let A (hd V3430) (let V3431 (shen.lazyderef (tl V3430) V3920) (if (= () V3431) (let NewHyp (tl V3426) (do (shen.incinfs) (unify! V V3420 V3920 (freeze (shen.newhyps Vs V3918 NewHyp V3920 V3921))))) (if (shen.pvar? V3431) (do (shen.bindv V3431 () V3920) (let Result (let NewHyp (tl V3426) (do (shen.incinfs) (unify! V V3420 V3920 (freeze (shen.newhyps Vs V3918 NewHyp V3920 V3921))))) (do (shen.unbindv V3431 V3920) Result))) false)))) (if (shen.pvar? V3430) (let A (shen.newpv V3920) (do (shen.bindv V3430 (cons A ()) V3920) (let Result (let NewHyp (tl V3426) (do (shen.incinfs) (unify! V V3420 V3920 (freeze (shen.newhyps Vs V3918 NewHyp V3920 V3921))))) (do (shen.unbindv V3430 V3920) Result)))) false))) (if (shen.pvar? V3429) (do (shen.bindv V3429 : V3920) (let Result (let V3432 (shen.lazyderef (tl V3428) V3920) (if (cons? V3432) (let A (hd V3432) (let V3433 (shen.lazyderef (tl V3432) V3920) (if (= () V3433) (let NewHyp (tl V3426) (do (shen.incinfs) (unify! V V3420 V3920 (freeze (shen.newhyps Vs V3918 NewHyp V3920 V3921))))) (if (shen.pvar? V3433) (do (shen.bindv V3433 () V3920) (let Result (let NewHyp (tl V3426) (do (shen.incinfs) (unify! V V3420 V3920 (freeze (shen.newhyps Vs V3918 NewHyp V3920 V3921))))) (do (shen.unbindv V3433 V3920) Result))) false)))) (if (shen.pvar? V3432) (let A (shen.newpv V3920) (do (shen.bindv V3432 (cons A ()) V3920) (let Result (let NewHyp (tl V3426) (do (shen.incinfs) (unify! V V3420 V3920 (freeze (shen.newhyps Vs V3918 NewHyp V3920 V3921))))) (do (shen.unbindv V3432 V3920) Result)))) false))) (do (shen.unbindv V3429 V3920) Result))) false))) (if (shen.pvar? V3428) (let A (shen.newpv V3920) (do (shen.bindv V3428 (cons : (cons A ())) V3920) (let Result (let NewHyp (tl V3426) (do (shen.incinfs) (unify! V V3420 V3920 (freeze (shen.newhyps Vs V3918 NewHyp V3920 V3921))))) (do (shen.unbindv V3428 V3920) Result)))) false)))) (if (shen.pvar? V3427) (let V (shen.newpv V3920) (let A (shen.newpv V3920) (do (shen.bindv V3427 (cons V (cons : (cons A ()))) V3920) (let Result (let NewHyp (tl V3426) (do (shen.incinfs) (unify! V V3420 V3920 (freeze (shen.newhyps Vs V3918 NewHyp V3920 V3921))))) (do (shen.unbindv V3427 V3920) Result))))) false))) (if (shen.pvar? V3426) (let V (shen.newpv V3920) (let A (shen.newpv V3920) (let NewHyp (shen.newpv V3920) (do (shen.bindv V3426 (cons (cons V (cons : (cons A ()))) NewHyp) V3920) (let Result (do (shen.incinfs) (unify! V V3420 V3920 (freeze (shen.newhyps Vs V3918 NewHyp V3920 V3921)))) (do (shen.unbindv V3426 V3920) Result)))))) false))))) false)) Case)))

(defun shen.patthyps (V3927 V3928 V3929) (cond ((= () V3927) V3929) ((and (cons? V3927) (and (cons? V3928) (and (cons? (tl V3928)) (and (= --> (hd (tl V3928))) (and (cons? (tl (tl V3928))) (= () (tl (tl (tl V3928))))))))) (adjoin (cons (hd V3927) (cons : (cons (hd V3928) ()))) (shen.patthyps (tl V3927) (hd (tl (tl V3928))) V3929))) (true (shen.f_error shen.patthyps))))

(defun shen.result-type (V3936 V3937) (cond ((and (= () V3936) (and (cons? V3937) (and (= --> (hd V3937)) (and (cons? (tl V3937)) (= () (tl (tl V3937))))))) (hd (tl V3937))) ((= () V3936) V3937) ((and (cons? V3936) (and (cons? V3937) (and (cons? (tl V3937)) (and (= --> (hd (tl V3937))) (and (cons? (tl (tl V3937))) (= () (tl (tl (tl V3937))))))))) (shen.result-type (tl V3936) (hd (tl (tl V3937))))) (true (shen.f_error shen.result-type))))

(defun shen.t*-patterns (V3943 V3944 V3945 V3946 V3947) (let Case (let V3412 (shen.lazyderef V3943 V3946) (if (= () V3412) (do (shen.incinfs) (thaw V3947)) false)) (if (= Case false) (let V3413 (shen.lazyderef V3943 V3946) (if (cons? V3413) (let Pattern (hd V3413) (let Patterns (tl V3413) (let V3414 (shen.lazyderef V3944 V3946) (if (cons? V3414) (let A (hd V3414) (let V3415 (shen.lazyderef (tl V3414) V3946) (if (cons? V3415) (let V3416 (shen.lazyderef (hd V3415) V3946) (if (= --> V3416) (let V3417 (shen.lazyderef (tl V3415) V3946) (if (cons? V3417) (let B (hd V3417) (let V3418 (shen.lazyderef (tl V3417) V3946) (if (= () V3418) (do (shen.incinfs) (shen.t* (cons Pattern (cons : (cons A ()))) V3945 V3946 (freeze (shen.t*-patterns Patterns B V3945 V3946 V3947)))) false))) false)) false)) false))) false)))) false)) Case)))

(defun shen.t*-action (V3953 V3954 V3955 V3956 V3957) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3389 (shen.lazyderef V3953 V3956) (if (cons? V3389) (let V3390 (shen.lazyderef (hd V3389) V3956) (if (= where V3390) (let V3391 (shen.lazyderef (tl V3389) V3956) (if (cons? V3391) (let P (hd V3391) (let V3392 (shen.lazyderef (tl V3391) V3956) (if (cons? V3392) (let Action (hd V3392) (let V3393 (shen.lazyderef (tl V3392) V3956) (if (= () V3393) (do (shen.incinfs) (cut Throwcontrol V3956 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V3955 V3956 (freeze (cut Throwcontrol V3956 (freeze (shen.t*-action Action V3954 (cons (cons P (cons : (cons verified ()))) V3955) V3956 V3957)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3394 (shen.lazyderef V3953 V3956) (if (cons? V3394) (let V3395 (shen.lazyderef (hd V3394) V3956) (if (= shen.choicepoint! V3395) (let V3396 (shen.lazyderef (tl V3394) V3956) (if (cons? V3396) (let V3397 (shen.lazyderef (hd V3396) V3956) (if (cons? V3397) (let V3398 (shen.lazyderef (hd V3397) V3956) (if (cons? V3398) (let V3399 (shen.lazyderef (hd V3398) V3956) (if (= fail-if V3399) (let V3400 (shen.lazyderef (tl V3398) V3956) (if (cons? V3400) (let F (hd V3400) (let V3401 (shen.lazyderef (tl V3400) V3956) (if (= () V3401) (let V3402 (shen.lazyderef (tl V3397) V3956) (if (cons? V3402) (let Action (hd V3402) (let V3403 (shen.lazyderef (tl V3402) V3956) (if (= () V3403) (let V3404 (shen.lazyderef (tl V3396) V3956) (if (= () V3404) (do (shen.incinfs) (cut Throwcontrol V3956 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V3954 V3955 V3956 V3957)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3405 (shen.lazyderef V3953 V3956) (if (cons? V3405) (let V3406 (shen.lazyderef (hd V3405) V3956) (if (= shen.choicepoint! V3406) (let V3407 (shen.lazyderef (tl V3405) V3956) (if (cons? V3407) (let Action (hd V3407) (let V3408 (shen.lazyderef (tl V3407) V3956) (if (= () V3408) (do (shen.incinfs) (cut Throwcontrol V3956 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V3954 V3955 V3956 V3957)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V3953 (cons : (cons V3954 ()))) V3955 V3956 V3957)) Case)) Case)) Case)))))

(defun findall (V3963 V3964 V3965 V3966 V3967) (let B (shen.newpv V3966) (let A (shen.newpv V3966) (do (shen.incinfs) (bind A (gensym shen.a) V3966 (freeze (bind B (set (shen.lazyderef A V3966) ()) V3966 (freeze (shen.findallhelp V3963 V3964 V3965 A V3966 V3967)))))))))

(defun shen.findallhelp (V3974 V3975 V3976 V3977 V3978 V3979) (let Case (do (shen.incinfs) (call V3975 V3978 (freeze (shen.remember V3977 V3974 V3978 (freeze (fwhen false V3978 V3979)))))) (if (= Case false) (do (shen.incinfs) (bind V3976 (value (shen.lazyderef V3977 V3978)) V3978 V3979)) Case)))

(defun shen.remember (V3984 V3985 V3986 V3987) (let B (shen.newpv V3986) (do (shen.incinfs) (bind B (set (shen.deref V3984 V3986) (cons (shen.deref V3985 V3986) (value (shen.deref V3984 V3986)))) V3986 V3987))))



