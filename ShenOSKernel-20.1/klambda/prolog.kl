"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.<defprolog> (V1803) (let Parse_shen.<predicate*> (shen.<predicate*> V1803) (if (not (= (fail) Parse_shen.<predicate*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<predicate*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (hd (shen.prolog->shen (map (lambda Parse_X (shen.insert-predicate (shen.hdtl Parse_shen.<predicate*>) Parse_X)) (shen.hdtl Parse_shen.<clauses*>))))) (fail))) (fail))))

(defun shen.prolog-error (V1812 V1813) (cond ((and (cons? V1813) (and (cons? (tl V1813)) (= () (tl (tl V1813))))) (simple-error (cn "prolog syntax error in " (shen.app V1812 (cn " here:

 " (shen.app (shen.next-50 50 (hd V1813)) "
" shen.a)) shen.a)))) (true (simple-error (cn "prolog syntax error in " (shen.app V1812 "
" shen.a))))))

(defun shen.next-50 (V1820 V1821) (cond ((= () V1821) "") ((= 0 V1820) "") ((cons? V1821) (cn (shen.decons-string (hd V1821)) (shen.next-50 (- V1820 1) (tl V1821)))) (true (shen.f_error shen.next-50))))

(defun shen.decons-string (V1823) (cond ((and (cons? V1823) (and (= cons (hd V1823)) (and (cons? (tl V1823)) (and (cons? (tl (tl V1823))) (= () (tl (tl (tl V1823)))))))) (shen.app (shen.eval-cons V1823) " " shen.s)) (true (shen.app V1823 " " shen.r))))

(defun shen.insert-predicate (V1826 V1827) (cond ((and (cons? V1827) (and (cons? (tl V1827)) (= () (tl (tl V1827))))) (cons (cons V1826 (hd V1827)) (cons :- (tl V1827)))) (true (shen.f_error shen.insert-predicate))))

(defun shen.<predicate*> (V1829) (if (cons? (hd V1829)) (let Parse_X (hd (hd V1829)) (shen.pair (hd (shen.pair (tl (hd V1829)) (shen.hdtl V1829))) Parse_X)) (fail)))

(defun shen.<clauses*> (V1831) (let YaccParse (let Parse_shen.<clause*> (shen.<clause*> V1831) (if (not (= (fail) Parse_shen.<clause*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<clause*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (cons (shen.hdtl Parse_shen.<clause*>) (shen.hdtl Parse_shen.<clauses*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1831) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<clause*> (V1833) (let Parse_shen.<head*> (shen.<head*> V1833) (if (not (= (fail) Parse_shen.<head*>)) (if (and (cons? (hd Parse_shen.<head*>)) (= <-- (hd (hd Parse_shen.<head*>)))) (let Parse_shen.<body*> (shen.<body*> (shen.pair (tl (hd Parse_shen.<head*>)) (shen.hdtl Parse_shen.<head*>))) (if (not (= (fail) Parse_shen.<body*>)) (let Parse_shen.<end*> (shen.<end*> Parse_shen.<body*>) (if (not (= (fail) Parse_shen.<end*>)) (shen.pair (hd Parse_shen.<end*>) (cons (shen.hdtl Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<body*>) ()))) (fail))) (fail))) (fail)) (fail))))

(defun shen.<head*> (V1835) (let YaccParse (let Parse_shen.<term*> (shen.<term*> V1835) (if (not (= (fail) Parse_shen.<term*>)) (let Parse_shen.<head*> (shen.<head*> Parse_shen.<term*>) (if (not (= (fail) Parse_shen.<head*>)) (shen.pair (hd Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<term*>) (shen.hdtl Parse_shen.<head*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1835) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<term*> (V1837) (if (cons? (hd V1837)) (let Parse_X (hd (hd V1837)) (if (and (not (= <-- Parse_X)) (shen.legitimate-term? Parse_X)) (shen.pair (hd (shen.pair (tl (hd V1837)) (shen.hdtl V1837))) (shen.eval-cons Parse_X)) (fail))) (fail)))

(defun shen.legitimate-term? (V1843) (cond ((and (cons? V1843) (and (= cons (hd V1843)) (and (cons? (tl V1843)) (and (cons? (tl (tl V1843))) (= () (tl (tl (tl V1843)))))))) (and (shen.legitimate-term? (hd (tl V1843))) (shen.legitimate-term? (hd (tl (tl V1843)))))) ((and (cons? V1843) (and (= mode (hd V1843)) (and (cons? (tl V1843)) (and (cons? (tl (tl V1843))) (and (= + (hd (tl (tl V1843)))) (= () (tl (tl (tl V1843))))))))) (shen.legitimate-term? (hd (tl V1843)))) ((and (cons? V1843) (and (= mode (hd V1843)) (and (cons? (tl V1843)) (and (cons? (tl (tl V1843))) (and (= - (hd (tl (tl V1843)))) (= () (tl (tl (tl V1843))))))))) (shen.legitimate-term? (hd (tl V1843)))) ((cons? V1843) false) (true true)))

(defun shen.eval-cons (V1845) (cond ((and (cons? V1845) (and (= cons (hd V1845)) (and (cons? (tl V1845)) (and (cons? (tl (tl V1845))) (= () (tl (tl (tl V1845)))))))) (cons (shen.eval-cons (hd (tl V1845))) (shen.eval-cons (hd (tl (tl V1845)))))) ((and (cons? V1845) (and (= mode (hd V1845)) (and (cons? (tl V1845)) (and (cons? (tl (tl V1845))) (= () (tl (tl (tl V1845)))))))) (cons mode (cons (shen.eval-cons (hd (tl V1845))) (tl (tl V1845))))) (true V1845)))

(defun shen.<body*> (V1847) (let YaccParse (let Parse_shen.<literal*> (shen.<literal*> V1847) (if (not (= (fail) Parse_shen.<literal*>)) (let Parse_shen.<body*> (shen.<body*> Parse_shen.<literal*>) (if (not (= (fail) Parse_shen.<body*>)) (shen.pair (hd Parse_shen.<body*>) (cons (shen.hdtl Parse_shen.<literal*>) (shen.hdtl Parse_shen.<body*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1847) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<literal*> (V1849) (let YaccParse (if (and (cons? (hd V1849)) (= ! (hd (hd V1849)))) (shen.pair (hd (shen.pair (tl (hd V1849)) (shen.hdtl V1849))) (cons cut (cons (intern "Throwcontrol") ()))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V1849)) (let Parse_X (hd (hd V1849)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V1849)) (shen.hdtl V1849))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<end*> (V1851) (if (cons? (hd V1851)) (let Parse_X (hd (hd V1851)) (if (= Parse_X ;) (shen.pair (hd (shen.pair (tl (hd V1851)) (shen.hdtl V1851))) Parse_X) (fail))) (fail)))

(defun cut (V1855 V1856 V1857) (let Result (thaw V1857) (if (= Result false) V1855 Result)))

(defun shen.insert_modes (V1859) (cond ((and (cons? V1859) (and (= mode (hd V1859)) (and (cons? (tl V1859)) (and (cons? (tl (tl V1859))) (= () (tl (tl (tl V1859)))))))) V1859) ((= () V1859) ()) ((cons? V1859) (cons (cons mode (cons (hd V1859) (cons + ()))) (cons mode (cons (shen.insert_modes (tl V1859)) (cons - ()))))) (true V1859)))

(defun shen.s-prolog (V1861) (map (lambda X (eval X)) (shen.prolog->shen V1861)))

(defun shen.prolog->shen (V1863) (map (lambda X (shen.compile_prolog_procedure X)) (shen.group_clauses (map (lambda X (shen.s-prolog_clause X)) (mapcan (lambda X (shen.head_abstraction X)) V1863)))))

(defun shen.s-prolog_clause (V1865) (cond ((and (cons? V1865) (and (cons? (tl V1865)) (and (= :- (hd (tl V1865))) (and (cons? (tl (tl V1865))) (= () (tl (tl (tl V1865)))))))) (cons (hd V1865) (cons :- (cons (map (lambda X (shen.s-prolog_literal X)) (hd (tl (tl V1865)))) ())))) (true (shen.f_error shen.s-prolog_clause))))

(defun shen.head_abstraction (V1867) (cond ((and (cons? V1867) (and (cons? (tl V1867)) (and (= :- (hd (tl V1867))) (and (cons? (tl (tl V1867))) (and (= () (tl (tl (tl V1867)))) (trap-error (< (shen.complexity_head (hd V1867)) (value shen.*maxcomplexity*)) (lambda _ false))))))) (cons V1867 ())) ((and (cons? V1867) (and (cons? (hd V1867)) (and (cons? (tl V1867)) (and (= :- (hd (tl V1867))) (and (cons? (tl (tl V1867))) (= () (tl (tl (tl V1867))))))))) (let Terms (map (lambda Y (gensym V)) (tl (hd V1867))) (let XTerms (shen.rcons_form (shen.remove_modes (tl (hd V1867)))) (let Literal (cons unify (cons (shen.cons_form Terms) (cons XTerms ()))) (let Clause (cons (cons (hd (hd V1867)) Terms) (cons :- (cons (cons Literal (hd (tl (tl V1867)))) ()))) (cons Clause ())))))) (true (shen.f_error shen.head_abstraction))))

(defun shen.complexity_head (V1873) (cond ((cons? V1873) (shen.safe-product (map (lambda X (shen.complexity X)) (tl V1873)))) (true (shen.f_error shen.complexity_head))))

(defun shen.safe-multiply (V1876 V1877) (* V1876 V1877))

(defun shen.complexity (V1886) (cond ((and (cons? V1886) (and (= mode (hd V1886)) (and (cons? (tl V1886)) (and (cons? (hd (tl V1886))) (and (= mode (hd (hd (tl V1886)))) (and (cons? (tl (hd (tl V1886)))) (and (cons? (tl (tl (hd (tl V1886))))) (and (= () (tl (tl (tl (hd (tl V1886)))))) (and (cons? (tl (tl V1886))) (= () (tl (tl (tl V1886))))))))))))) (shen.complexity (hd (tl V1886)))) ((and (cons? V1886) (and (= mode (hd V1886)) (and (cons? (tl V1886)) (and (cons? (hd (tl V1886))) (and (cons? (tl (tl V1886))) (and (= + (hd (tl (tl V1886)))) (= () (tl (tl (tl V1886)))))))))) (shen.safe-multiply 2 (shen.safe-multiply (shen.complexity (cons mode (cons (hd (hd (tl V1886))) (tl (tl V1886))))) (shen.complexity (cons mode (cons (tl (hd (tl V1886))) (tl (tl V1886)))))))) ((and (cons? V1886) (and (= mode (hd V1886)) (and (cons? (tl V1886)) (and (cons? (hd (tl V1886))) (and (cons? (tl (tl V1886))) (and (= - (hd (tl (tl V1886)))) (= () (tl (tl (tl V1886)))))))))) (shen.safe-multiply (shen.complexity (cons mode (cons (hd (hd (tl V1886))) (tl (tl V1886))))) (shen.complexity (cons mode (cons (tl (hd (tl V1886))) (tl (tl V1886))))))) ((and (cons? V1886) (and (= mode (hd V1886)) (and (cons? (tl V1886)) (and (cons? (tl (tl V1886))) (and (= () (tl (tl (tl V1886)))) (variable? (hd (tl V1886)))))))) 1) ((and (cons? V1886) (and (= mode (hd V1886)) (and (cons? (tl V1886)) (and (cons? (tl (tl V1886))) (and (= + (hd (tl (tl V1886)))) (= () (tl (tl (tl V1886))))))))) 2) ((and (cons? V1886) (and (= mode (hd V1886)) (and (cons? (tl V1886)) (and (cons? (tl (tl V1886))) (and (= - (hd (tl (tl V1886)))) (= () (tl (tl (tl V1886))))))))) 1) (true (shen.complexity (cons mode (cons V1886 (cons + ())))))))

(defun shen.safe-product (V1888) (cond ((= () V1888) 1) ((cons? V1888) (shen.safe-multiply (hd V1888) (shen.safe-product (tl V1888)))) (true (shen.f_error shen.safe-product))))

(defun shen.s-prolog_literal (V1890) (cond ((and (cons? V1890) (and (= is (hd V1890)) (and (cons? (tl V1890)) (and (cons? (tl (tl V1890))) (= () (tl (tl (tl V1890)))))))) (cons bind (cons (hd (tl V1890)) (cons (shen.insert_deref (hd (tl (tl V1890)))) ())))) ((and (cons? V1890) (and (= when (hd V1890)) (and (cons? (tl V1890)) (= () (tl (tl V1890)))))) (cons fwhen (cons (shen.insert_deref (hd (tl V1890))) ()))) ((and (cons? V1890) (and (= bind (hd V1890)) (and (cons? (tl V1890)) (and (cons? (tl (tl V1890))) (= () (tl (tl (tl V1890)))))))) (cons bind (cons (hd (tl V1890)) (cons (shen.insert_lazyderef (hd (tl (tl V1890)))) ())))) ((and (cons? V1890) (and (= fwhen (hd V1890)) (and (cons? (tl V1890)) (= () (tl (tl V1890)))))) (cons fwhen (cons (shen.insert_lazyderef (hd (tl V1890))) ()))) ((cons? V1890) V1890) (true (shen.f_error shen.s-prolog_literal))))

(defun shen.insert_deref (V1892) (cond ((variable? V1892) (cons shen.deref (cons V1892 (cons ProcessN ())))) ((cons? V1892) (cons (shen.insert_deref (hd V1892)) (shen.insert_deref (tl V1892)))) (true V1892)))

(defun shen.insert_lazyderef (V1894) (cond ((variable? V1894) (cons shen.lazyderef (cons V1894 (cons ProcessN ())))) ((cons? V1894) (cons (shen.insert_lazyderef (hd V1894)) (shen.insert_lazyderef (tl V1894)))) (true V1894)))

(defun shen.group_clauses (V1896) (cond ((= () V1896) ()) ((cons? V1896) (let Group (shen.collect (lambda X (shen.same_predicate? (hd V1896) X)) V1896) (let Rest (difference V1896 Group) (cons Group (shen.group_clauses Rest))))) (true (shen.f_error shen.group_clauses))))

(defun shen.collect (V1901 V1902) (cond ((= () V1902) ()) ((cons? V1902) (if (V1901 (hd V1902)) (cons (hd V1902) (shen.collect V1901 (tl V1902))) (shen.collect V1901 (tl V1902)))) (true (shen.f_error shen.collect))))

(defun shen.same_predicate? (V1921 V1922) (cond ((and (cons? V1921) (and (cons? (hd V1921)) (and (cons? V1922) (cons? (hd V1922))))) (= (hd (hd V1921)) (hd (hd V1922)))) (true (shen.f_error shen.same_predicate?))))

(defun shen.compile_prolog_procedure (V1924) (let F (shen.procedure_name V1924) (let Shen (shen.clauses-to-shen F V1924) Shen)))

(defun shen.procedure_name (V1938) (cond ((and (cons? V1938) (and (cons? (hd V1938)) (cons? (hd (hd V1938))))) (hd (hd (hd V1938)))) (true (shen.f_error shen.procedure_name))))

(defun shen.clauses-to-shen (V1941 V1942) (let Linear (map (lambda X (shen.linearise-clause X)) V1942) (let Arity (shen.prolog-aritycheck V1941 (map (lambda X (head X)) V1942)) (let Parameters (shen.parameters Arity) (let AUM_instructions (map (lambda X (shen.aum X Parameters)) Linear) (let Code (shen.catch-cut (shen.nest-disjunct (map (lambda X (shen.aum_to_shen X)) AUM_instructions))) (let ShenDef (cons define (cons V1941 (append Parameters (append (cons ProcessN (cons Continuation ())) (cons -> (cons Code ())))))) ShenDef)))))))

(defun shen.catch-cut (V1944) (cond ((not (shen.occurs? cut V1944)) V1944) (true (cons let (cons Throwcontrol (cons (cons shen.catchpoint ()) (cons (cons shen.cutpoint (cons Throwcontrol (cons V1944 ()))) ())))))))

(defun shen.catchpoint () (set shen.*catch* (+ 1 (value shen.*catch*))))

(defun shen.cutpoint (V1952 V1953) (cond ((= V1953 V1952) false) (true V1953)))

(defun shen.nest-disjunct (V1955) (cond ((and (cons? V1955) (= () (tl V1955))) (hd V1955)) ((cons? V1955) (shen.lisp-or (hd V1955) (shen.nest-disjunct (tl V1955)))) (true (shen.f_error shen.nest-disjunct))))

(defun shen.lisp-or (V1958 V1959) (cons let (cons Case (cons V1958 (cons (cons if (cons (cons = (cons Case (cons false ()))) (cons V1959 (cons Case ())))) ())))))

(defun shen.prolog-aritycheck (V1964 V1965) (cond ((and (cons? V1965) (= () (tl V1965))) (- (length (hd V1965)) 1)) ((and (cons? V1965) (cons? (tl V1965))) (if (= (length (hd V1965)) (length (hd (tl V1965)))) (shen.prolog-aritycheck V1964 (tl V1965)) (simple-error (cn "arity error in prolog procedure " (shen.app (cons V1964 ()) "
" shen.a))))) (true (shen.f_error shen.prolog-aritycheck))))

(defun shen.linearise-clause (V1967) (cond ((and (cons? V1967) (and (cons? (tl V1967)) (and (= :- (hd (tl V1967))) (and (cons? (tl (tl V1967))) (= () (tl (tl (tl V1967)))))))) (let Linear (shen.linearise (cons (hd V1967) (tl (tl V1967)))) (shen.clause_form Linear))) (true (shen.f_error shen.linearise-clause))))

(defun shen.clause_form (V1969) (cond ((and (cons? V1969) (and (cons? (tl V1969)) (= () (tl (tl V1969))))) (cons (shen.explicit_modes (hd V1969)) (cons :- (cons (shen.cf_help (hd (tl V1969))) ())))) (true (shen.f_error shen.clause_form))))

(defun shen.explicit_modes (V1971) (cond ((cons? V1971) (cons (hd V1971) (map (lambda X (shen.em_help X)) (tl V1971)))) (true (shen.f_error shen.explicit_modes))))

(defun shen.em_help (V1973) (cond ((and (cons? V1973) (and (= mode (hd V1973)) (and (cons? (tl V1973)) (and (cons? (tl (tl V1973))) (= () (tl (tl (tl V1973)))))))) V1973) (true (cons mode (cons V1973 (cons + ()))))))

(defun shen.cf_help (V1975) (cond ((and (cons? V1975) (and (= where (hd V1975)) (and (cons? (tl V1975)) (and (cons? (hd (tl V1975))) (and (= = (hd (hd (tl V1975)))) (and (cons? (tl (hd (tl V1975)))) (and (cons? (tl (tl (hd (tl V1975))))) (and (= () (tl (tl (tl (hd (tl V1975)))))) (and (cons? (tl (tl V1975))) (= () (tl (tl (tl V1975))))))))))))) (cons (cons (if (value shen.*occurs*) unify! unify) (tl (hd (tl V1975)))) (shen.cf_help (hd (tl (tl V1975)))))) (true V1975)))

(defun occurs-check (V1981) (cond ((= + V1981) (set shen.*occurs* true)) ((= - V1981) (set shen.*occurs* false)) (true (simple-error "occurs-check expects + or -
"))))

(defun shen.aum (V1984 V1985) (cond ((and (cons? V1984) (and (cons? (hd V1984)) (and (cons? (tl V1984)) (and (= :- (hd (tl V1984))) (and (cons? (tl (tl V1984))) (= () (tl (tl (tl V1984))))))))) (let MuApplication (shen.make_mu_application (cons shen.mu (cons (tl (hd V1984)) (cons (shen.continuation_call (tl (hd V1984)) (hd (tl (tl V1984)))) ()))) V1985) (shen.mu_reduction MuApplication +))) (true (shen.f_error shen.aum))))

(defun shen.continuation_call (V1988 V1989) (let VTerms (cons ProcessN (shen.extract_vars V1988)) (let VBody (shen.extract_vars V1989) (let Free (remove Throwcontrol (difference VBody VTerms)) (shen.cc_help Free V1989)))))

(defun remove (V1992 V1993) (shen.remove-h V1992 V1993 ()))

(defun shen.remove-h (V2000 V2001 V2002) (cond ((= () V2001) (reverse V2002)) ((and (cons? V2001) (= (hd V2001) V2000)) (shen.remove-h (hd V2001) (tl V2001) V2002)) ((cons? V2001) (shen.remove-h V2000 (tl V2001) (cons (hd V2001) V2002))) (true (shen.f_error shen.remove-h))))

(defun shen.cc_help (V2005 V2006) (cond ((and (= () V2005) (= () V2006)) (cons shen.pop (cons shen.the (cons shen.stack ())))) ((= () V2006) (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V2005 (cons and (cons shen.then (cons (cons shen.pop (cons shen.the (cons shen.stack ()))) ()))))))))) ((= () V2005) (cons call (cons shen.the (cons shen.continuation (cons V2006 ()))))) (true (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V2005 (cons and (cons shen.then (cons (cons call (cons shen.the (cons shen.continuation (cons V2006 ())))) ())))))))))))

(defun shen.make_mu_application (V2009 V2010) (cond ((and (cons? V2009) (and (= shen.mu (hd V2009)) (and (cons? (tl V2009)) (and (= () (hd (tl V2009))) (and (cons? (tl (tl V2009))) (and (= () (tl (tl (tl V2009)))) (= () V2010))))))) (hd (tl (tl V2009)))) ((and (cons? V2009) (and (= shen.mu (hd V2009)) (and (cons? (tl V2009)) (and (cons? (hd (tl V2009))) (and (cons? (tl (tl V2009))) (and (= () (tl (tl (tl V2009)))) (cons? V2010))))))) (cons (cons shen.mu (cons (hd (hd (tl V2009))) (cons (shen.make_mu_application (cons shen.mu (cons (tl (hd (tl V2009))) (tl (tl V2009)))) (tl V2010)) ()))) (cons (hd V2010) ()))) (true (shen.f_error shen.make_mu_application))))

(defun shen.mu_reduction (V2019 V2020) (cond ((and (cons? V2019) (and (cons? (hd V2019)) (and (= shen.mu (hd (hd V2019))) (and (cons? (tl (hd V2019))) (and (cons? (hd (tl (hd V2019)))) (and (= mode (hd (hd (tl (hd V2019))))) (and (cons? (tl (hd (tl (hd V2019))))) (and (cons? (tl (tl (hd (tl (hd V2019)))))) (and (= () (tl (tl (tl (hd (tl (hd V2019))))))) (and (cons? (tl (tl (hd V2019)))) (and (= () (tl (tl (tl (hd V2019))))) (and (cons? (tl V2019)) (= () (tl (tl V2019))))))))))))))) (shen.mu_reduction (cons (cons shen.mu (cons (hd (tl (hd (tl (hd V2019))))) (tl (tl (hd V2019))))) (tl V2019)) (hd (tl (tl (hd (tl (hd V2019)))))))) ((and (cons? V2019) (and (cons? (hd V2019)) (and (= shen.mu (hd (hd V2019))) (and (cons? (tl (hd V2019))) (and (cons? (tl (tl (hd V2019)))) (and (= () (tl (tl (tl (hd V2019))))) (and (cons? (tl V2019)) (and (= () (tl (tl V2019))) (= _ (hd (tl (hd V2019)))))))))))) (shen.mu_reduction (hd (tl (tl (hd V2019)))) V2020)) ((and (cons? V2019) (and (cons? (hd V2019)) (and (= shen.mu (hd (hd V2019))) (and (cons? (tl (hd V2019))) (and (cons? (tl (tl (hd V2019)))) (and (= () (tl (tl (tl (hd V2019))))) (and (cons? (tl V2019)) (and (= () (tl (tl V2019))) (shen.ephemeral_variable? (hd (tl (hd V2019))) (hd (tl V2019))))))))))) (subst (hd (tl V2019)) (hd (tl (hd V2019))) (shen.mu_reduction (hd (tl (tl (hd V2019)))) V2020))) ((and (cons? V2019) (and (cons? (hd V2019)) (and (= shen.mu (hd (hd V2019))) (and (cons? (tl (hd V2019))) (and (cons? (tl (tl (hd V2019)))) (and (= () (tl (tl (tl (hd V2019))))) (and (cons? (tl V2019)) (and (= () (tl (tl V2019))) (variable? (hd (tl (hd V2019)))))))))))) (cons let (cons (hd (tl (hd V2019))) (cons shen.be (cons (hd (tl V2019)) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V2019)))) V2020) ()))))))) ((and (cons? V2019) (and (cons? (hd V2019)) (and (= shen.mu (hd (hd V2019))) (and (cons? (tl (hd V2019))) (and (cons? (tl (tl (hd V2019)))) (and (= () (tl (tl (tl (hd V2019))))) (and (cons? (tl V2019)) (and (= () (tl (tl V2019))) (and (= - V2020) (shen.prolog_constant? (hd (tl (hd V2019))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V2019))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V2019))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V2019)))) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V2019) (and (cons? (hd V2019)) (and (= shen.mu (hd (hd V2019))) (and (cons? (tl (hd V2019))) (and (cons? (tl (tl (hd V2019)))) (and (= () (tl (tl (tl (hd V2019))))) (and (cons? (tl V2019)) (and (= () (tl (tl V2019))) (and (= + V2020) (shen.prolog_constant? (hd (tl (hd V2019))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V2019))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V2019))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V2019)))) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (hd (tl (hd V2019))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V2019)))) +) ())))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) ((and (cons? V2019) (and (cons? (hd V2019)) (and (= shen.mu (hd (hd V2019))) (and (cons? (tl (hd V2019))) (and (cons? (hd (tl (hd V2019)))) (and (cons? (tl (tl (hd V2019)))) (and (= () (tl (tl (tl (hd V2019))))) (and (cons? (tl V2019)) (and (= () (tl (tl V2019))) (= - V2020)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V2019))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V2019)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V2019)))) (tl (tl (hd V2019))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V2019) (and (cons? (hd V2019)) (and (= shen.mu (hd (hd V2019))) (and (cons? (tl (hd V2019))) (and (cons? (hd (tl (hd V2019)))) (and (cons? (tl (tl (hd V2019)))) (and (= () (tl (tl (tl (hd V2019))))) (and (cons? (tl V2019)) (and (= () (tl (tl V2019))) (= + V2020)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V2019))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V2019)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V2019)))) (tl (tl (hd V2019))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (shen.extract_vars (hd (tl (hd V2019)))) (cons and (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (shen.rcons_form (shen.remove_modes (hd (tl (hd V2019))))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V2019)))) +) ())))))) ())))))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) (true V2019)))

(defun shen.rcons_form (V2022) (cond ((cons? V2022) (cons cons (cons (shen.rcons_form (hd V2022)) (cons (shen.rcons_form (tl V2022)) ())))) (true V2022)))

(defun shen.remove_modes (V2024) (cond ((and (cons? V2024) (and (= mode (hd V2024)) (and (cons? (tl V2024)) (and (cons? (tl (tl V2024))) (and (= + (hd (tl (tl V2024)))) (= () (tl (tl (tl V2024))))))))) (shen.remove_modes (hd (tl V2024)))) ((and (cons? V2024) (and (= mode (hd V2024)) (and (cons? (tl V2024)) (and (cons? (tl (tl V2024))) (and (= - (hd (tl (tl V2024)))) (= () (tl (tl (tl V2024))))))))) (shen.remove_modes (hd (tl V2024)))) ((cons? V2024) (cons (shen.remove_modes (hd V2024)) (shen.remove_modes (tl V2024)))) (true V2024)))

(defun shen.ephemeral_variable? (V2027 V2028) (and (variable? V2027) (variable? V2028)))

(defun shen.prolog_constant? (V2038) (cond ((cons? V2038) false) (true true)))

(defun shen.aum_to_shen (V2040) (cond ((and (cons? V2040) (and (= let (hd V2040)) (and (cons? (tl V2040)) (and (cons? (tl (tl V2040))) (and (= shen.be (hd (tl (tl V2040)))) (and (cons? (tl (tl (tl V2040)))) (and (cons? (tl (tl (tl (tl V2040))))) (and (= in (hd (tl (tl (tl (tl V2040)))))) (and (cons? (tl (tl (tl (tl (tl V2040)))))) (= () (tl (tl (tl (tl (tl (tl V2040)))))))))))))))) (cons let (cons (hd (tl V2040)) (cons (shen.aum_to_shen (hd (tl (tl (tl V2040))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V2040))))))) ()))))) ((and (cons? V2040) (and (= shen.the (hd V2040)) (and (cons? (tl V2040)) (and (= shen.result (hd (tl V2040))) (and (cons? (tl (tl V2040))) (and (= shen.of (hd (tl (tl V2040)))) (and (cons? (tl (tl (tl V2040)))) (and (= shen.dereferencing (hd (tl (tl (tl V2040))))) (and (cons? (tl (tl (tl (tl V2040))))) (= () (tl (tl (tl (tl (tl V2040))))))))))))))) (cons shen.lazyderef (cons (shen.aum_to_shen (hd (tl (tl (tl (tl V2040)))))) (cons ProcessN ())))) ((and (cons? V2040) (and (= if (hd V2040)) (and (cons? (tl V2040)) (and (cons? (tl (tl V2040))) (and (= shen.then (hd (tl (tl V2040)))) (and (cons? (tl (tl (tl V2040)))) (and (cons? (tl (tl (tl (tl V2040))))) (and (= shen.else (hd (tl (tl (tl (tl V2040)))))) (and (cons? (tl (tl (tl (tl (tl V2040)))))) (= () (tl (tl (tl (tl (tl (tl V2040)))))))))))))))) (cons if (cons (shen.aum_to_shen (hd (tl V2040))) (cons (shen.aum_to_shen (hd (tl (tl (tl V2040))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V2040))))))) ()))))) ((and (cons? V2040) (and (cons? (tl V2040)) (and (= is (hd (tl V2040))) (and (cons? (tl (tl V2040))) (and (= shen.a (hd (tl (tl V2040)))) (and (cons? (tl (tl (tl V2040)))) (and (= shen.variable (hd (tl (tl (tl V2040))))) (= () (tl (tl (tl (tl V2040)))))))))))) (cons shen.pvar? (cons (hd V2040) ()))) ((and (cons? V2040) (and (cons? (tl V2040)) (and (= is (hd (tl V2040))) (and (cons? (tl (tl V2040))) (and (= shen.a (hd (tl (tl V2040)))) (and (cons? (tl (tl (tl V2040)))) (and (= shen.non-empty (hd (tl (tl (tl V2040))))) (and (cons? (tl (tl (tl (tl V2040))))) (and (= list (hd (tl (tl (tl (tl V2040)))))) (= () (tl (tl (tl (tl (tl V2040))))))))))))))) (cons cons? (cons (hd V2040) ()))) ((and (cons? V2040) (and (= shen.rename (hd V2040)) (and (cons? (tl V2040)) (and (= shen.the (hd (tl V2040))) (and (cons? (tl (tl V2040))) (and (= shen.variables (hd (tl (tl V2040)))) (and (cons? (tl (tl (tl V2040)))) (and (= in (hd (tl (tl (tl V2040))))) (and (cons? (tl (tl (tl (tl V2040))))) (and (= () (hd (tl (tl (tl (tl V2040)))))) (and (cons? (tl (tl (tl (tl (tl V2040)))))) (and (= and (hd (tl (tl (tl (tl (tl V2040))))))) (and (cons? (tl (tl (tl (tl (tl (tl V2040))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V2040)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V2040)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V2040)))))))))))))))))))))))) (shen.aum_to_shen (hd (tl (tl (tl (tl (tl (tl (tl V2040)))))))))) ((and (cons? V2040) (and (= shen.rename (hd V2040)) (and (cons? (tl V2040)) (and (= shen.the (hd (tl V2040))) (and (cons? (tl (tl V2040))) (and (= shen.variables (hd (tl (tl V2040)))) (and (cons? (tl (tl (tl V2040)))) (and (= in (hd (tl (tl (tl V2040))))) (and (cons? (tl (tl (tl (tl V2040))))) (and (cons? (hd (tl (tl (tl (tl V2040)))))) (and (cons? (tl (tl (tl (tl (tl V2040)))))) (and (= and (hd (tl (tl (tl (tl (tl V2040))))))) (and (cons? (tl (tl (tl (tl (tl (tl V2040))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V2040)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V2040)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V2040)))))))))))))))))))))))) (cons let (cons (hd (hd (tl (tl (tl (tl V2040)))))) (cons (cons shen.newpv (cons ProcessN ())) (cons (shen.aum_to_shen (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (tl (hd (tl (tl (tl (tl V2040)))))) (tl (tl (tl (tl (tl V2040))))))))))) ()))))) ((and (cons? V2040) (and (= bind (hd V2040)) (and (cons? (tl V2040)) (and (cons? (tl (tl V2040))) (and (= shen.to (hd (tl (tl V2040)))) (and (cons? (tl (tl (tl V2040)))) (and (cons? (tl (tl (tl (tl V2040))))) (and (= in (hd (tl (tl (tl (tl V2040)))))) (and (cons? (tl (tl (tl (tl (tl V2040)))))) (= () (tl (tl (tl (tl (tl (tl V2040)))))))))))))))) (cons do (cons (cons shen.bindv (cons (hd (tl V2040)) (cons (shen.chwild (hd (tl (tl (tl V2040))))) (cons ProcessN ())))) (cons (cons let (cons Result (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V2040))))))) (cons (cons do (cons (cons shen.unbindv (cons (hd (tl V2040)) (cons ProcessN ()))) (cons Result ()))) ())))) ())))) ((and (cons? V2040) (and (cons? (tl V2040)) (and (= is (hd (tl V2040))) (and (cons? (tl (tl V2040))) (and (= identical (hd (tl (tl V2040)))) (and (cons? (tl (tl (tl V2040)))) (and (= shen.to (hd (tl (tl (tl V2040))))) (and (cons? (tl (tl (tl (tl V2040))))) (= () (tl (tl (tl (tl (tl V2040)))))))))))))) (cons = (cons (hd (tl (tl (tl (tl V2040))))) (cons (hd V2040) ())))) ((= shen.failed! V2040) false) ((and (cons? V2040) (and (= shen.the (hd V2040)) (and (cons? (tl V2040)) (and (= head (hd (tl V2040))) (and (cons? (tl (tl V2040))) (and (= shen.of (hd (tl (tl V2040)))) (and (cons? (tl (tl (tl V2040)))) (= () (tl (tl (tl (tl V2040)))))))))))) (cons hd (tl (tl (tl V2040))))) ((and (cons? V2040) (and (= shen.the (hd V2040)) (and (cons? (tl V2040)) (and (= tail (hd (tl V2040))) (and (cons? (tl (tl V2040))) (and (= shen.of (hd (tl (tl V2040)))) (and (cons? (tl (tl (tl V2040)))) (= () (tl (tl (tl (tl V2040)))))))))))) (cons tl (tl (tl (tl V2040))))) ((and (cons? V2040) (and (= shen.pop (hd V2040)) (and (cons? (tl V2040)) (and (= shen.the (hd (tl V2040))) (and (cons? (tl (tl V2040))) (and (= shen.stack (hd (tl (tl V2040)))) (= () (tl (tl (tl V2040)))))))))) (cons do (cons (cons shen.incinfs ()) (cons (cons thaw (cons Continuation ())) ())))) ((and (cons? V2040) (and (= call (hd V2040)) (and (cons? (tl V2040)) (and (= shen.the (hd (tl V2040))) (and (cons? (tl (tl V2040))) (and (= shen.continuation (hd (tl (tl V2040)))) (and (cons? (tl (tl (tl V2040)))) (= () (tl (tl (tl (tl V2040)))))))))))) (cons do (cons (cons shen.incinfs ()) (cons (shen.call_the_continuation (shen.chwild (hd (tl (tl (tl V2040))))) ProcessN Continuation) ())))) (true V2040)))

(defun shen.chwild (V2042) (cond ((= V2042 _) (cons shen.newpv (cons ProcessN ()))) ((cons? V2042) (map (lambda Z (shen.chwild Z)) V2042)) (true V2042)))

(defun shen.newpv (V2044) (let Count+1 (+ (<-address (value shen.*varcounter*) V2044) 1) (let IncVar (address-> (value shen.*varcounter*) V2044 Count+1) (let Vector (<-address (value shen.*prologvectors*) V2044) (let ResizeVectorIfNeeded (if (= Count+1 (limit Vector)) (shen.resizeprocessvector V2044 Count+1) shen.skip) (shen.mk-pvar Count+1))))))

(defun shen.resizeprocessvector (V2047 V2048) (let Vector (<-address (value shen.*prologvectors*) V2047) (let BigVector (shen.resize-vector Vector (+ V2048 V2048) shen.-null-) (address-> (value shen.*prologvectors*) V2047 BigVector))))

(defun shen.resize-vector (V2052 V2053 V2054) (let BigVector (address-> (absvector (+ 1 V2053)) 0 V2053) (shen.copy-vector V2052 BigVector (limit V2052) V2053 V2054)))

(defun shen.copy-vector (V2060 V2061 V2062 V2063 V2064) (shen.copy-vector-stage-2 (+ 1 V2062) (+ V2063 1) V2064 (shen.copy-vector-stage-1 1 V2060 V2061 (+ 1 V2062))))

(defun shen.copy-vector-stage-1 (V2072 V2073 V2074 V2075) (cond ((= V2075 V2072) V2074) (true (shen.copy-vector-stage-1 (+ 1 V2072) V2073 (address-> V2074 V2072 (<-address V2073 V2072)) V2075))))

(defun shen.copy-vector-stage-2 (V2083 V2084 V2085 V2086) (cond ((= V2084 V2083) V2086) (true (shen.copy-vector-stage-2 (+ V2083 1) V2084 V2085 (address-> V2086 V2083 V2085)))))

(defun shen.mk-pvar (V2088) (address-> (address-> (absvector 2) 0 shen.pvar) 1 V2088))

(defun shen.pvar? (V2090) (and (absvector? V2090) (= (<-address/or V2090 0 (freeze shen.not-pvar)) shen.pvar)))

(defun shen.bindv (V2094 V2095 V2096) (let Vector (<-address (value shen.*prologvectors*) V2096) (address-> Vector (<-address V2094 1) V2095)))

(defun shen.unbindv (V2099 V2100) (let Vector (<-address (value shen.*prologvectors*) V2100) (address-> Vector (<-address V2099 1) shen.-null-)))

(defun shen.incinfs () (set shen.*infs* (+ 1 (value shen.*infs*))))

(defun shen.call_the_continuation (V2104 V2105 V2106) (cond ((and (cons? V2104) (and (cons? (hd V2104)) (= () (tl V2104)))) (cons (hd (hd V2104)) (append (tl (hd V2104)) (cons V2105 (cons V2106 ()))))) ((and (cons? V2104) (cons? (hd V2104))) (let NewContinuation (shen.newcontinuation (tl V2104) V2105 V2106) (cons (hd (hd V2104)) (append (tl (hd V2104)) (cons V2105 (cons NewContinuation ())))))) (true (shen.f_error shen.call_the_continuation))))

(defun shen.newcontinuation (V2110 V2111 V2112) (cond ((= () V2110) V2112) ((and (cons? V2110) (cons? (hd V2110))) (cons freeze (cons (cons (hd (hd V2110)) (append (tl (hd V2110)) (cons V2111 (cons (shen.newcontinuation (tl V2110) V2111 V2112) ())))) ()))) (true (shen.f_error shen.newcontinuation))))

(defun return (V2120 V2121 V2122) (shen.deref V2120 V2121))

(defun shen.measure&return (V2130 V2131 V2132) (do (shen.prhush (shen.app (value shen.*infs*) " inferences
" shen.a) (stoutput)) (shen.deref V2130 V2131)))

(defun unify (V2137 V2138 V2139 V2140) (shen.lzy= (shen.lazyderef V2137 V2139) (shen.lazyderef V2138 V2139) V2139 V2140))

(defun shen.lzy= (V2162 V2163 V2164 V2165) (cond ((= V2163 V2162) (thaw V2165)) ((shen.pvar? V2162) (bind V2162 V2163 V2164 V2165)) ((shen.pvar? V2163) (bind V2163 V2162 V2164 V2165)) ((and (cons? V2162) (cons? V2163)) (shen.lzy= (shen.lazyderef (hd V2162) V2164) (shen.lazyderef (hd V2163) V2164) V2164 (freeze (shen.lzy= (shen.lazyderef (tl V2162) V2164) (shen.lazyderef (tl V2163) V2164) V2164 V2165)))) (true false)))

(defun shen.deref (V2168 V2169) (cond ((cons? V2168) (cons (shen.deref (hd V2168) V2169) (shen.deref (tl V2168) V2169))) (true (if (shen.pvar? V2168) (let Value (shen.valvector V2168 V2169) (if (= Value shen.-null-) V2168 (shen.deref Value V2169))) V2168))))

(defun shen.lazyderef (V2172 V2173) (if (shen.pvar? V2172) (let Value (shen.valvector V2172 V2173) (if (= Value shen.-null-) V2172 (shen.lazyderef Value V2173))) V2172))

(defun shen.valvector (V2176 V2177) (<-address (<-address (value shen.*prologvectors*) V2177) (<-address V2176 1)))

(defun unify! (V2182 V2183 V2184 V2185) (shen.lzy=! (shen.lazyderef V2182 V2184) (shen.lazyderef V2183 V2184) V2184 V2185))

(defun shen.lzy=! (V2207 V2208 V2209 V2210) (cond ((= V2208 V2207) (thaw V2210)) ((and (shen.pvar? V2207) (not (shen.occurs? V2207 (shen.deref V2208 V2209)))) (bind V2207 V2208 V2209 V2210)) ((and (shen.pvar? V2208) (not (shen.occurs? V2208 (shen.deref V2207 V2209)))) (bind V2208 V2207 V2209 V2210)) ((and (cons? V2207) (cons? V2208)) (shen.lzy=! (shen.lazyderef (hd V2207) V2209) (shen.lazyderef (hd V2208) V2209) V2209 (freeze (shen.lzy=! (shen.lazyderef (tl V2207) V2209) (shen.lazyderef (tl V2208) V2209) V2209 V2210)))) (true false)))

(defun shen.occurs? (V2222 V2223) (cond ((= V2223 V2222) true) ((cons? V2223) (or (shen.occurs? V2222 (hd V2223)) (shen.occurs? V2222 (tl V2223)))) (true false)))

(defun identical (V2228 V2229 V2230 V2231) (shen.lzy== (shen.lazyderef V2228 V2230) (shen.lazyderef V2229 V2230) V2230 V2231))

(defun shen.lzy== (V2253 V2254 V2255 V2256) (cond ((= V2254 V2253) (thaw V2256)) ((and (cons? V2253) (cons? V2254)) (shen.lzy== (shen.lazyderef (hd V2253) V2255) (shen.lazyderef (hd V2254) V2255) V2255 (freeze (shen.lzy== (tl V2253) (tl V2254) V2255 V2256)))) (true false)))

(defun shen.pvar (V2258) (cn "Var" (shen.app (<-address V2258 1) "" shen.a)))

(defun bind (V2263 V2264 V2265 V2266) (do (shen.bindv V2263 V2264 V2265) (let Result (thaw V2266) (do (shen.unbindv V2263 V2265) Result))))

(defun fwhen (V2284 V2285 V2286) (cond ((= true V2284) (thaw V2286)) ((= false V2284) false) (true (simple-error (cn "fwhen expects a boolean: not " (shen.app V2284 "%" shen.s))))))

(defun call (V2302 V2303 V2304) (cond ((cons? V2302) (shen.call-help (function (shen.lazyderef (hd V2302) V2303)) (tl V2302) V2303 V2304)) (true false)))

(defun shen.call-help (V2309 V2310 V2311 V2312) (cond ((= () V2310) (V2309 V2311 V2312)) ((cons? V2310) (shen.call-help (V2309 (hd V2310)) (tl V2310) V2311 V2312)) (true (shen.f_error shen.call-help))))

(defun shen.intprolog (V2314) (cond ((and (cons? V2314) (cons? (hd V2314))) (let ProcessN (shen.start-new-prolog-process) (shen.intprolog-help (hd (hd V2314)) (shen.insert-prolog-variables (cons (tl (hd V2314)) (cons (tl V2314) ())) ProcessN) ProcessN))) (true (shen.f_error shen.intprolog))))

(defun shen.intprolog-help (V2318 V2319 V2320) (cond ((and (cons? V2319) (and (cons? (tl V2319)) (= () (tl (tl V2319))))) (shen.intprolog-help-help V2318 (hd V2319) (hd (tl V2319)) V2320)) (true (shen.f_error shen.intprolog-help))))

(defun shen.intprolog-help-help (V2325 V2326 V2327 V2328) (cond ((= () V2326) (V2325 V2328 (freeze (shen.call-rest V2327 V2328)))) ((cons? V2326) (shen.intprolog-help-help (V2325 (hd V2326)) (tl V2326) V2327 V2328)) (true (shen.f_error shen.intprolog-help-help))))

(defun shen.call-rest (V2333 V2334) (cond ((= () V2333) true) ((and (cons? V2333) (and (cons? (hd V2333)) (cons? (tl (hd V2333))))) (shen.call-rest (cons (cons ((hd (hd V2333)) (hd (tl (hd V2333)))) (tl (tl (hd V2333)))) (tl V2333)) V2334)) ((and (cons? V2333) (and (cons? (hd V2333)) (= () (tl (hd V2333))))) ((hd (hd V2333)) V2334 (freeze (shen.call-rest (tl V2333) V2334)))) (true (shen.f_error shen.call-rest))))

(defun shen.start-new-prolog-process () (let IncrementProcessCounter (set shen.*process-counter* (+ 1 (value shen.*process-counter*))) (shen.initialise-prolog IncrementProcessCounter)))

(defun shen.insert-prolog-variables (V2337 V2338) (shen.insert-prolog-variables-help V2337 (shen.flatten V2337) V2338))

(defun shen.insert-prolog-variables-help (V2346 V2347 V2348) (cond ((= () V2347) V2346) ((and (cons? V2347) (variable? (hd V2347))) (let V (shen.newpv V2348) (let XV/Y (subst V (hd V2347) V2346) (let Z-Y (remove (hd V2347) (tl V2347)) (shen.insert-prolog-variables-help XV/Y Z-Y V2348))))) ((cons? V2347) (shen.insert-prolog-variables-help V2346 (tl V2347) V2348)) (true (shen.f_error shen.insert-prolog-variables-help))))

(defun shen.initialise-prolog (V2350) (let Vector (address-> (value shen.*prologvectors*) V2350 (shen.fillvector (vector 10) 1 10 shen.-null-)) (let Counter (address-> (value shen.*varcounter*) V2350 1) V2350)))



